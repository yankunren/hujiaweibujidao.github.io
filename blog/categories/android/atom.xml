<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | Hujiawei Bujidao]]></title>
  <link href="http://hujiaweibujidao.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://hujiaweibujidao.github.io/"/>
  <updated>2014-11-26T12:52:21+08:00</updated>
  <id>http://hujiaweibujidao.github.io/</id>
  <author>
    <name><![CDATA[hujiawei]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android NDK and OpenCV development with Android Studio]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2014/10/22/android-ndk-and-opencv-development-with-android-studio/"/>
    <updated>2014-10-22T09:51:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2014/10/22/android-ndk-and-opencv-development-with-android-studio</id>
    <content type="html"><![CDATA[<p>—————- If you do <strong>NOT</strong> know Chinese, you can just skip this part —————-</p>

<p>一直打算将原来的XFace进行改进，最近终于有了些时间可以动手了，改进计划如下：开发上使用Android Studio作为新的开发环境，配上新的构建系统Gradle；应用上将修改原来的UI设计，内部代码也将有很大的变化，可能会用上ContentProvider和Service等略高级内容；算法上打算让应用扩展性增强以适应不同的算法，并结合强大的Android Studio和Gradle让这个项目变得更加丰富。说了一堆废话，言归正传，本文的重点是介绍如何在Android Studio中进行NDK开发(目前它还不完全支持NDK开发)，难点是NDK中还包含OpenCV的动态库。最后的最后，本文剩下部分将使用英文，因为它要成为我在StackOverflow上的处女答，么么哒 ~O(∩_∩)O~</p>

<p>—————————- Here is the right stuff you may need ——————————–</p>

<h4 id="this-post-shows-how-to-develop-an-android-ndk-application-with-opencv-included-using-android-studio-and-gradle-if-youre-working-on-migrating-your-original-eclipse-project-to-android-studio-you-may-find-this-post-is-what-exactly-you-want">This post shows how to develop an Android NDK application with OpenCV included using Android Studio and Gradle. If you’re working on migrating your original Eclipse Project to Android Studio, you may find this post is what exactly you want!</h4>

<p>OK，Let’s start! </p>

<h3 id="section-1--three-things-you-must-know">Section 1:  Three things you must know</h3>

<h4 id="firstly-if-you-are-not-familiar-with-android-studio-and-gradle-you-may-find-these-links-useful-if-you-already-know-these-well-skip-this-part">1.Firstly, if you are not familiar with Android Studio and Gradle, you may find these links useful. (if you already know these well, skip this part)</h4>

<p>①<a href="http://developer.android.com/sdk/installing/create-project.html">Creating a new Project with Android Studio</a></p>

<p>②<a href="http://developer.android.com/sdk/installing/studio-build.html">Building Your Project with Gradle</a></p>

<p>③<a href="http://tools.android.com/tech-docs/new-build-system/user-guide">Gradle Plugin User Guide</a>  or you may want to read a Chinese commented version in my blog <a href="http://hujiaweibujidao.github.io/blog/2014/10/13/gradle-plugin-user-guide-1/">here</a>.</p>

<h4 id="secondly-if-your-android-ndk-project-is-not-that-complicatedfor-example-having-no-opencv-included-you-may-wanna-see-ph0b-s-introduction-here-its-quite-a-nice-job-with-a-video-recorded-you-can-also-follow-section-2-in-this-post-to-get-a-simple-android-ndk-demo-application">2.Secondly, if your android ndk project is not that complicated(for example, having no opencv included), you may wanna see <code>ph0b</code> ‘s introduction here, it’s quite a nice job with a video recorded! (you can also follow Section 2 in this post to get a simple Android NDK demo application)</h4>

<p><a href="http://ph0b.com/android-studio-gradle-and-ndk-integration/"><code>ph0b</code>’s post: ANDROID STUDIO, GRADLE AND NDK INTEGRATION</a></p>

<h4 id="thirdly-if-those-above-two-do-not-meet-your-needs-then-i-think-you-may-want-to-customize-the-androidmk-with-gradle-in-android-studio-thanks-to-gaku-ueda--he-had-made-a-great-job-explaining-how-to-achieve-that-goal-actually-i-have-found-another-nicer-solution-without-adding-that-many-codes-and-also-achieve-that-goal---find-it-out-in-the-next-sections">3.Thirdly, if those above two do not meet your needs, then I think you may want to customize the Android.mk with Gradle in Android Studio. Thanks to <code>Gaku Ueda</code> , he had made a great job explaining how to achieve that goal. Actually I have found another nicer solution without adding that many codes and also achieve that goal. :-) Find it out in the next sections.</h4>

<p><a href="http://blog.gaku.net/ndk/"><code>Gaku Ueda</code>’s post: Using custom Android.mk with Gradle/Android Studio</a></p>

<p>OK, I will cover all above and give another nice solution in the end, have fun!</p>

<h3 id="section-2-a-simple-android-ndk-demo-application">Section 2: A simple Android NDK demo application</h3>

<p>This section shows creating a simple Android NDK demo application, if you already know, you can directly go the section 3.</p>

<p>1.Create a new Android project named <code>NDKDemo</code> with a blank Activity in AS(=Android Studio).</p>

<p>2.Give an <code>id</code> to the <code>TextView</code> in <code>activity_my.xml</code> such as <code>android:id="@+id/textview"</code>, then add these codes in <code>MyActivity.java</code>.</p>

<p>```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_my);</p>

<pre><code>TextView textView = (TextView) findViewById(R.id.textview);
textView.setText(hello()); }
</code></pre>

<p>static {
    System.loadLibrary(“hello”);
}</p>

<p>public native String hello();
```</p>

<p>3.Create a new directory <code>jni</code> in folder <code>app/src/main</code>, then you have <code>java</code>, <code>jni</code> and <code>res</code> in this folder.</p>

<p>4.This step is very important! <strong>You can add a external tool to run the <code>javah</code> command without typing that much code!</strong> </p>

<p>Open AS’s <code>Preferences</code>, then find <code>External Tools</code> in <code>IDE Settings</code>, click <code>+</code> to add one tool with the following configurations. (Make sure you have add <code>JDK tools</code>  in your <code>system path</code>, if you don’t know how, click <a href="http://hujiaweibujidao.github.io/blog/2014/02/21/android-ndk-and-opencv-development-4/">here</a>)</p>

<p><img src="http://hujiaweibujidao.github.io/images/javah_as.png" alt="image" /></p>

<p>With the help of this tool, each time we right click on a <code>class file</code>, then choose <code>Android Tools -&gt; javah</code> to run this tool, it will automatically generate a <code>C head file</code> for us in the target folder <code>$ModuleFileDir$/src/main/jni</code> , in this case, it is <code>app/src/main/jni</code>. Try this on <code>MyActivity.java</code> file now! The console will print out a log like:</p>

<p><code>/usr/bin/javah -v -jni -d /Users/hujiawei/AndroidStudioProjects/NDKDemo/app/src/main/jni com.android.hacks.ndkdemo.MyActivity
[Creating file RegularFileObject[/Users/hujiawei/AndroidStudioProjects/NDKDemo/app/src/main/jni/
com_android_hacks_ndkdemo_MyActivity.h]]</code></p>

<p>Then you get a <code>com_android_hacks_ndkdemo_MyActivity.h</code> file in <code>jni</code>  folder with the following content.</p>

<p>```
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_android_hacks_ndkdemo_MyActivity */</jni.h></p>

<h1 id="ifndef-includedcomandroidhacksndkdemomyactivity">ifndef _Included_com_android_hacks_ndkdemo_MyActivity</h1>
<p>#define _Included_com_android_hacks_ndkdemo_MyActivity
#ifdef __cplusplus
extern “C” {
#endif
/*
 * Class:     com_android_hacks_ndkdemo_MyActivity
 * Method:    hello
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_android_hacks_ndkdemo_MyActivity_hello
  (JNIEnv *, jobject);</p>

<h1 id="ifdef-cplusplus">ifdef __cplusplus</h1>
<p>}
#endif
#endif
```</p>

<p>5.Write a simple <code>C</code> implementation file named <code>main.c</code> in <code>jni</code> folder</p>

<p>```
#include <jni.h>
#include "com_android_hacks_ndkdemo_MyActivity.h"</jni.h></p>

<p>JNIEXPORT jstring JNICALL Java_com_android_hacks_ndkdemo_MyActivity_hello
  (JNIEnv * env, jobject obj){
    return (*env)-&gt;NewStringUTF(env, “Hello from JNI”);
  }
```</p>

<p>6.In the <code>build.gradle</code> file under <code>app</code> module, add the following codes to configure <code>ndk</code> in <code>defaultConfig</code> element, here we just give the uni module a name <code>hello</code>, you can find other configurations in <a href="http://tools.android.com/tech-docs/new-build-system/user-guide">Gradle Plugin User Guide</a>.</p>

<p>```
defaultConfig {
    applicationId “com.android.hacks.ndkdemo”
    minSdkVersion 16
    targetSdkVersion 20
    versionCode 1
    versionName “1.0”</p>

<pre><code>ndk{
    moduleName "hello"
} } ```
</code></pre>

<p>7.In order to let Gradle run <code>ndk-build</code> command (in some task, maybe <code>NdkCompile</code> task), we should configure the <code>ndk.dir</code> in <code>local.properties</code> file in Project root.</p>

<p><code>
sdk.dir=/Volumes/hujiawei/Users/hujiawei/Android/android_sdk
ndk.dir=/Volumes/hujiawei/Users/hujiawei/Android/android_ndk
</code></p>

<p>8.OK, everything is ready, click <code>Run</code> to give it a try, you will see the result like</p>

<p><img src="http://hujiaweibujidao.github.io/images/ndkdemo_ss.png" alt="image" /></p>

<p>All right, so what’s happening inside?</p>

<p><strong>Since you have a <code>jni</code> folder, Gradle will consider it as a default native code folder. When Gradle builds the <code>app</code>, it will run <code>ndk-build</code> command(since you have configured <code>ndk.dir</code>,  Gradle knows where to find it) with a generated <code>Android.mk</code> file(locates in <code>app/build/intermediates/ndk/debug/Android.mk</code>), after compiling the native codes, it will generate the <code>libs</code> and <code>obj</code> folder into folder  <code>app/build/intermediates/ndk/debug/</code>. Gradle will then package the <code>libs</code> into final <code>apk</code> file in folder <code>app/build/outputs/apk/app-debug.apk</code>(you can unarchive this file to check whether <code>libs</code> is contained)</strong></p>

<p><code>app/build/intermediates/ndk/debug</code> (<code>lib</code> and <code>obj</code> folders)</p>

<p><img src="http://hujiaweibujidao.github.io/images/ndkdemo_ndk.png" alt="image" /></p>

<p><code>app/build/outputs/apk/app-debug.apk</code> (and files within it)</p>

<p><img src="http://hujiaweibujidao.github.io/images/ndkdemo_apk.png" alt="image" /></p>

<h3 id="secontion-3-using-opencv">Secontion 3: Using OpenCV</h3>

<p>If your project do not use OpenCV, then the section 2 is just enough. But what if you wanna use OpenCV to do other stuff? Of course, we want to use <code>OpenCV for Android</code> instead of  <code>JavaCV</code> here, and Of course, we need to package OpenCV library for Android into our application’s APK file (then users who use this app does not have to install <code>OpenCV Manager</code>). So, how can we achieve these goals?</p>

<p>The simplest way has been posted by <code>TGMCians</code> on Stack Overflow <a href="http://stackoverflow.com/questions/17767557/how-to-use-opencv-in-android-studio-using-gradle-build-tool?answertab=active#tab-top">here</a>, that is, let the main app include the OpenCV library as a dependency, and copy all <code>&lt;abi&gt;/*.so</code> files in OpenCV for Android SDK to <code>jniLibs</code> folder under <code>app/src/main/</code>, Gradle will automatically package these <code>&lt;abi&gt;/*.so</code> files into <code>libs</code> folder within the final APK file. Of course, this method will work, but it has a few backwards: (1) Unless you only copy the needed <code>*.so</code> files, you will always have a large APK due to this reason; (2) How about the building of the <code>jni</code> files? How to run <code>ndk-build</code> if these files contain <code>opencv</code> related codes? </p>

<p>So, here comes to our <code>Using custom Android.mk with Gradle and Android Studio</code> part. For testing, we first creat an <code>Android.mk</code> and an <code>Application.mk</code> file under <code>jni</code> folder. </p>

<p><code>Android.mk</code></p>

<p>```
LOCAL_PATH := $(call my-dir)</p>

<p>include $(CLEAR_VARS)</p>

<p>LOCAL_SRC_FILES := main.c
LOCAL_LDLIBS += -llog
LOCAL_MODULE := hello</p>

<p>include $(BUILD_SHARED_LIBRARY)
```</p>

<p><code>Application.mk</code></p>

<p><code>
APP_ABI := armeabi
APP_PLATFORM := android-16
</code></p>

<p>Thanks to <code>Gaku Ueda</code>, he had made a great job explaining how to achieve that goal with <a href="http://blog.gaku.net/ndk/">this post</a>. The core idea of his method is to run <code>ndk-build</code> command in some task, then zip the <code>&lt;abi&gt;/*.so</code> files under the output <code>app/build/libs/</code> folder into a <code>jar</code> file which is finally put in <code>app/build/libs/</code> folder, then add a compile dependency to this jar file. The key code for his method listed below</p>

<p><strong>Notice 1: When using custom Android.mk, we should first disable Gradle to build the <code>jni</code> folder as before, and <code>sourceSets.main.jni.srcDirs = []</code> just does this job!</strong></p>

<p><strong>Notice 2: The code is not exactly the same with Gaku Ueda’s code: <code>tasks.withType(Compile)</code> to <code>tasks.withType(JavaCompile)</code>, because <code>Compile</code> is deprecated.</strong></p>

<p><strong>Notice 3: You can get  <code>$ndkDir</code> variable with <code>project.plugins.findPlugin('com.android.application').getNdkFolder()</code> or you can define it in <code>grade.properties</code> file under Project root, so you need to add <code>ndkDir=path/to/your/ndk</code> in that file, if the file is not created, simply create a new one.</strong></p>

<p>```
android{
	…
    sourceSets.main.jni.srcDirs = []</p>

<pre><code>task ndkBuild(type: Exec, description: 'Compile JNI source via NDK') {
    ndkDir = project.plugins.findPlugin('com.android.application').getNdkFolder()
    commandLine "$ndkDir/ndk-build",
            'NDK_PROJECT_PATH=build',
            'APP_BUILD_SCRIPT=src/main/jni/Android.mk',
            'NDK_APPLICATION_MK=src/main/jni/Application.mk'
}

task ndkLibsToJar(type: Zip, dependsOn: 'ndkBuild', description: 'Create a JAR of the native libs') {
    destinationDir new File(buildDir, 'libs')
    baseName 'ndk-libs'
    extension 'jar'
    from(new File(buildDir, 'libs')) { include '**/*.so' }
    into 'lib/'
}

tasks.withType(JavaCompile) {
    compileTask -&gt; compileTask.dependsOn ndkLibsToJar
}
... }
</code></pre>

<p>dependencies {
    compile fileTree(dir: ‘libs’, include: [’<em>.jar’])
    // add begin
    compile fileTree(dir: new File(buildDir, ‘libs’), include: ‘</em>.jar’)
    // add end
}
```</p>

<p>But we can still do a little improvements here. We have already know that Gradle will take <code>jniLibs</code> folder as its default native libraries folder, so we can simply output the <code>libs/&lt;abi&gt;/*.so</code> files generated by <code>ndk-build</code> command into <code>jniLibs</code> folder, so there’s no need to zip these <code>*.so</code> files into a <code>jar</code> file. </p>

<p>The final <code>build.gradle</code> file under <code>app</code> module</p>

<p>```
apply plugin: ‘com.android.application’</p>

<p>android {
    compileSdkVersion 20
    buildToolsVersion “20.0.0”</p>

<pre><code>defaultConfig {
    applicationId "com.android.hacks.ndkdemo"
    minSdkVersion 16
    targetSdkVersion 20
    versionCode 1
    versionName "1.0"
}

// add begin
sourceSets.main.jni.srcDirs = []

task ndkBuild(type: Exec, description: 'Compile JNI source via NDK') {
    ndkDir = project.plugins.findPlugin('com.android.application').getNdkFolder()
    commandLine "$ndkDir/ndk-build",
            'NDK_PROJECT_PATH=build/intermediates/ndk',
            'NDK_LIBS_OUT=src/main/jniLibs',
            'APP_BUILD_SCRIPT=src/main/jni/Android.mk',
            'NDK_APPLICATION_MK=src/main/jni/Application.mk'
}

tasks.withType(JavaCompile) {
    compileTask -&gt; compileTask.dependsOn ndkBuild
}
// add end

buildTypes {
    release {
        runProguard false
        proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
    }
} }
</code></pre>

<p>dependencies {
    compile fileTree(dir: ‘libs’, include: [’*.jar’])
}
```</p>

<p>So simple, right? <code>'NDK_LIBS_OUT=src/main/jniLibs'</code> helps us do the right job!</p>

<p>For testing, you can also add some lines relating with OpenCV in your <code>Android.mk</code> file and some line in your <code>main.c</code> to check whether everything is readlly working. For example, add <code>#include &lt;opencv2/core/core.hpp&gt;</code> in <code>main.c</code> file, and change  <code>Android.mk</code> to </p>

<p>```
LOCAL_PATH := $(call my-dir)</p>

<p>include $(CLEAR_VARS)</p>

<h1 id="opencv">opencv</h1>
<p>OPENCVROOT:= /Volumes/hujiawei/Users/hujiawei/Android/opencv_sdk
OPENCV_CAMERA_MODULES:=on
OPENCV_INSTALL_MODULES:=on
OPENCV_LIB_TYPE:=SHARED
include ${OPENCVROOT}/sdk/native/jni/OpenCV.mk</p>

<p>LOCAL_SRC_FILES := main.c
LOCAL_LDLIBS += -llog
LOCAL_MODULE := hello</p>

<p>include $(BUILD_SHARED_LIBRARY)
```</p>

<p>In Gradle Console window, you can see these similar lines</p>

<p><img src="http://hujiaweibujidao.github.io/images/ndkdemo_gradle.png" alt="image" /></p>

<p><code>*.so</code> files relating with OpenCV has been packaged into the final APK</p>

<p><img src="http://hujiaweibujidao.github.io/images/ndkdemo_opencvlibs.png" alt="image" /></p>

<h4 id="one-more-thing"><strong>One More Thing</strong></h4>

<p>Of course, maybe you don’t want to change your <code>build.grale</code> file with that much code, and Of course, you also don’t want to run <code>ndk-build</code> outside the IDE, then copy the <code>&lt;abi&gt;/*.so</code> files into <code>jniLibs</code> folder each time you want to rebuild the native codes!</p>

<p>At last, I came out another nicer solution, if you like, that is to create a <code>ndk-build</code> external tool in Android Studio, and every time you want to rebuild the native codes, simply run the external tool, then it automatically generates the <code>libs/&lt;abi&gt;/*.so</code> files into <code>jniLibs</code> folder, so everything is ready to run this app, :-)</p>

<p>The configuration is simple</p>

<p>Parameters:  <code>NDK_PROJECT_PATH=$ModuleFileDir$/build/intermediates/ndk NDK_LIBS_OUT=$ModuleFileDir$/src/main/jniLibs NDK_APPLICATION_MK=$ModuleFileDir$/src/main/jni/Application.mk APP_BUILD_SCRIPT=$ModuleFileDir$/src/main/jni/Android.mk V=1</code></p>

<p><img src="http://hujiaweibujidao.github.io/images/ndk_build_as.png" alt="image" /></p>

<p>OK, I hope it is helpful. Let me know if it is really helpful, or tell me what’s your problem. :-)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gradle Plugin for Android Development User Guide (2)]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2014/10/15/gradle-plugin-user-guide-2/"/>
    <updated>2014-10-15T12:00:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2014/10/15/gradle-plugin-user-guide-2</id>
    <content type="html"><![CDATA[<p>Gradle Plugin for Android Development User Guide (2)</p>

<p>阅读本文前请先阅读第一部分：<a href="http://hujiaweibujidao.github.io/blog/2014/10/15/gradle-plugin-user-guide-1/">http://hujiaweibujidao.github.io/blog/2014/10/15/gradle-plugin-user-guide-1</a></p>

<p>原文地址：<a href="http://tools.android.com/tech-docs/new-build-system/user-guide">http://tools.android.com/tech-docs/new-build-system/user-guide</a></p>

<h3 id="testing">Testing</h3>

<p>[现在我们可以直接将test application集成到我们的application project中，没有必要再创建一个独立的test project了]</p>

<p>Building a test application is integrated into the application project. There is no need for a separate test project anymore.</p>

<h4 id="basics-and-configuration">Basics and Configuration</h4>

<p>[测试代码默认存放在<code>src/androidTest/</code> 目录下，使用Android Testing Framework 我们可以创建unit tests，instrumentation tests, 和 uiautomator tests.]</p>

<p>As mentioned previously, next to the <code>main</code> sourceSet is the <code>androidTest</code> sourceSet, located by default in <code>src/androidTest/</code></p>

<p>From this sourceSet is built a test apk that can be deployed to a device to test the application using the <code>Android testing framework</code>. This can contain unit tests, instrumentation tests, and later uiautomator tests.</p>

<p>[test app的<code>AndroidManifest.xml</code> 文件是自动生成的，所以它不需要指定位置，此外，我们没必要设置test application的instrumentation节点的<code>targetPackage</code> 属性，因为它会被test app的package name填充进去，这也就是为什么test app的Manifest文件是自动生成的]</p>

<p>The sourceSet should not contain an <code>AndroidManifest.xml</code> as it is automatically generated.</p>

<p>There are a few values that can be configured for the test app: [test app可以指定的属性]</p>

<p><code>testPackageName</code>     <br />
<code>testInstrumentationRunner</code>      <br />
<code>testHandleProfiling</code>      <br />
<code>testFunctionalTest</code>         </p>

<p>As seen previously, those are configured in the defaultConfig object:</p>

<p><code>java
android {
    defaultConfig {
        testPackageName "com.test.foo"
        testInstrumentationRunner "android.test.InstrumentationTestRunner"
        testHandleProfiling true
        testFunctionalTest true
    }
}
</code></p>

<p><strong>The value of the <code>targetPackage</code> attribute of the instrumentation node in the test application manifest is automatically filled with the package name of the tested app, even if it is customized through the <code>defaultConfig</code> and/or the Build Type objects. This is one of the reason the manifest is generated automatically.</strong></p>

<p>Additionally, the sourceSet can be configured to have its own dependencies.
By default, the application and its own dependencies are added to the test app classpath, but this can be extended with </p>

<p><code>
dependencies {
    androidTestCompile 'com.google.guava:guava:11.0.2'
}
</code></p>

<p>[test app是通过任务<code>assembleTest</code> 来构建的，它不是main assemble任务的依赖项，所以它是在test运行时自动调用的。目前只有debug这个build type会被测试，当然也可以自定义]</p>

<p><strong>The test app is built by the task <code>assembleTest</code>. It is not a dependency of the main assemble task, and is instead called automatically when the tests are set to run.</strong></p>

<p><strong>Currently only one Build Type is tested. By default it is the <code>debug</code> Build Type, but this can be reconfigured with:</strong></p>

<p><code>
android {
    ...
    testBuildType "staging"
}
</code></p>

<h4 id="running-tests">Running tests</h4>

<p>[前面提到过，在所有已连接的设备上进行check的任务是<code>connectedCheck</code>，它依赖任务<code>androidTest</code>，该任务的工作是并行地在所有已连接的设备上运行测试，任何一个设备测试失败的话，build就会失败。测试的结果会保存在XML文件中，存放在<code>build/androidTest-results</code> 目录下，当然也可以修改目标目录]</p>

<p>As mentioned previously, checks requiring a connected device are launched with the anchor task called <code>connectedCheck</code>.</p>

<p>This depends on the task <code>androidTest</code> and therefore will run it. This task does the following:  [<code>androidTest</code> 任务的工作流程]</p>

<p>1 Ensure the app and the test app are built (depending on <code>assembleDebug</code> and <code>assembleTest</code>)  <br />
2 Install both apps    <br />
3 Run the tests     <br />
4 Uninstall both apps.      </p>

<p>If more than one device is connected, all tests are run in parallel on all connected devices. If one of the test fails, on any device, the build will fail.</p>

<p>All test results are stored as XML files under</p>

<p><code>build/androidTest-results</code></p>

<p>(This is similar to regular jUnit results that are stored under <code>build/test-results</code>)</p>

<p>This can be configured with</p>

<p>```
android {
    …</p>

<pre><code>testOptions {
    resultsDir = "$project.buildDir/foo/results"
} } ```
</code></pre>

<p><strong>The value of <code>android.testOptions.resultsDir</code> is evaluated with <code>Project.file(String)</code></strong></p>

<h4 id="testing-android-libraries">Testing Android Libraries</h4>

<p>[测试android library project和测试一般的application差不多，区别在于整个library和它的依赖项都会被自动添加到test app，Manifest文件也被整合到test app的Manifest中。此外，<code>androidTest</code> 任务只能安装和卸载test APK]</p>

<p>Testing Android Library project is done exactly the same way as application projects.</p>

<p>The only difference is that the whole library (and its dependencies) is automatically added as a Library dependency to the test app. The result is that the test APK includes not only its own code, but also the library itself and all its dependencies.</p>

<p>The manifest of the Library is merged into the manifest of the test app (as is the case for any project referencing this Library).</p>

<p>The <code>androidTest</code> task is changed to only install (and uninstall) the test APK (since there are no other APK to install.)</p>

<p>Everything else is identical.</p>

<h4 id="test-reports">Test reports</h4>

<p>[在进行单元测试时，Gradle会输出一份HTML文档形式的报告。Android插件在此之上进行扩展，输出一份整合了所有已连接设备的测试结果的测试报告]</p>

<p>When running unit tests, Gradle outputs an HTML report to easily look at the results.</p>

<p>The Android plugins build on this and extends the HTML report to aggregate the results from all connected devices.</p>

<h4 id="single-projects">Single projects</h4>

<p>The project is automatically generated upon running the tests. Its default location is <code>build/reports/androidTests</code></p>

<p>This is similar to the jUnit report location, which is <code>build/reports/tests</code>, or other reports usually located in <code>build/reports/&lt;plugin&gt;/</code></p>

<p>The location can be customized with</p>

<p>```
android {
    …</p>

<pre><code>testOptions {
    reportDir = "$project.buildDir/foo/report"
} } ```
</code></pre>

<p>The report will aggregate tests that ran on different devices.</p>

<h4 id="multi-projects-reports">Multi-projects reports</h4>

<p>[对于多项目的测试，可以使用插件<code>android-reporting</code> 来将所有的测试结果输出到一个单一的报告中，而且这个设置必须是要设置在根项目的<code>build.gradle</code> 文件中]</p>

<p>In a multi project setup with application(s) and library(ies) projects, when running all tests at the same time, it might be useful to generate a single reports for all tests.</p>

<p>To do this, a different plugin is available in the same artifact. It can be applied with:</p>

<p>```
buildscript {
    repositories {
        mavenCentral()
    }</p>

<pre><code>dependencies {
    classpath 'com.android.tools.build:gradle:0.5.6'
} }
</code></pre>

<p>apply plugin: ‘android-reporting’
```</p>

<p>This should be applied to the root project, ie in <code>build.gradle</code> next to <code>settings.gradle</code></p>

<p>[在项目根目录下使用下面的命令可以保证运行所有的测试并聚合所有的测试结果，其中的<code>--continue</code> 选项能够保证即使某个设备在测试过程中出现了问题也不会打断其他的设备继续测试]</p>

<p>Then from the root folder, the following command line will run all the tests and aggregate the reports:</p>

<p><code>
gradle deviceCheck mergeAndroidReports --continue
</code></p>

<p>Note: the <code>--continue</code> option ensure that all tests, from all sub-projects will be run even if one of them fails. Without it the first failing test will interrupt the run and not all projects may have their tests run.</p>

<h4 id="lint-support">Lint support</h4>

<p>[lint可以指出程序中可能出现的issue，android插件同样支持]</p>

<p>As of version 0.7.0, you can run lint for a specific variant, or for all variants, in which case it produces a report which describes which specific variants a given issue applies to.</p>

<p>You can configure lint by adding a <code>lintOptions</code> section like following. You typically only specify a few of these; this section shows all the available options.</p>

<p>```
android {
    lintOptions {
        // set to true to turn off analysis progress reporting by lint
        quiet true
        // if true, stop the gradle build if errors are found
        abortOnError false
        // if true, only report errors
        ignoreWarnings true
        // if true, emit full/absolute paths to files with errors (true by default)
        //absolutePaths true
        // if true, check all issues, including those that are off by default
        checkAllWarnings true
        // if true, treat all warnings as errors
        warningsAsErrors true
        // turn off checking the given issue id’s
        disable ‘TypographyFractions’,’TypographyQuotes’
        // turn on the given issue id’s
        enable ‘RtlHardcoded’,’RtlCompat’, ‘RtlEnabled’
        // check <em>only</em> the given issue id’s
        check ‘NewApi’, ‘InlinedApi’
        // if true, don’t include source code lines in the error output
        noLines true
        // if true, show all locations for an error, do not truncate lists, etc.
        showAll true
        // Fallback lint configuration (default severities, etc.)
        lintConfig file(“default-lint.xml”)
        // if true, generate a text report of issues (false by default)
        textReport true
        // location to write the output; can be a file or ‘stdout’
        textOutput ‘stdout’
        // if true, generate an XML report for use by for example Jenkins
        xmlReport false
        // file to write report to (if not specified, defaults to lint-results.xml)
        xmlOutput file(“lint-report.xml”)
        // if true, generate an HTML report (with issue explanations, sourcecode, etc)
        htmlReport true
        // optional path to report (default will be lint-results.html in the builddir)
        htmlOutput file(“lint-report.html”)</p>

<p>// set to true to have all release builds run lint on issues with severity=fatal
   // and abort the build (controlled by abortOnError above) if fatal issues are found
   checkReleaseBuilds true
        // Set the severity of the given issues to fatal (which means they will be
        // checked during release builds (even if the lint target is not included)
        fatal ‘NewApi’, ‘InlineApi’
        // Set the severity of the given issues to error
        error ‘Wakelock’, ‘TextViewEdits’
        // Set the severity of the given issues to warning
        warning ‘ResourceAsColor’
        // Set the severity of the given issues to ignore (same as disabling the check)
        ignore ‘TypographyQuotes’
    }
}
```</p>

<h3 id="build-variants">Build Variants</h3>

<p>One goal of the new build system is to enable creating different versions of the same application.</p>

<p>There are two main use cases: [同一套程序代码生成多种不同的结果的应用场景]</p>

<p>(1) Different versions of the same application</p>

<p>For instance, a free/demo version vs the “pro” paid application. [一个是展示应用，另一个是真正的付费应用]</p>

<p>Same application packaged differently for multi-apk in Google Play Store.
See <a href="http://developer.android.com/google/play/publishing/multiple-apks.html">http://developer.android.com/google/play/publishing/multiple-apks.html </a> for more information.</p>

<p>(2) A combination of 1. and 2. </p>

<p>The goal was to be able to generate these different APKs from the same project, as opposed to using a single Library Projects and 2+ Application Projects.</p>

<h4 id="product-flavors">Product flavors</h4>

<p>[product flavor是一个项目的特别定制版的应用程序输出，单个项目可以有很多不同的product flavors，它们的名称不要和build type和sourceSet的名称相同]</p>

<p>A product flavor defines a customized version of the application build by the project. A single project can have different flavors which change the generated application.</p>

<p><strong>This new concept is designed to help when the differences are very minimum. If the answer to “Is this the same application?” is yes, then this is probably the way to go over Library Projects.</strong></p>

<p>Product flavors are declared using a productFlavors DSL container:</p>

<p>```
android {
    ….</p>

<pre><code>productFlavors {
    flavor1 {
        ...
    }

    flavor2 {
        ...
    }
} } ```
</code></pre>

<p>This creates two flavors, called flavor1 and flavor2.</p>

<p>Note: The name of the flavors cannot collide with existing Build Type names, or with the <code>androidTest</code> sourceSet.</p>

<p>[重要的式子：每个build type和product flavor的组合就是一个build variant]</p>

<p><strong>Build Type + Product Flavor = Build Variant</strong>  </p>

<p>As we have seen before, each Build Type generates a new APK.</p>

<p>Product Flavors do the same: the output of the project becomes all possible combinations of Build Types and, if applicable, Product Flavors.</p>

<p><strong>Each (Build Type, Product Flavor) combination is called a Build Variant.</strong></p>

<p>For instance, with the default <code>debug</code> and <code>release</code> Build Types, the above example generates four Build Variants:</p>

<p><code>Flavor1 - debug</code>    <br />
<code>Flavor1 - release</code>    <br />
<code>Flavor2 - debug</code>    <br />
<code>Flavor2 - release</code>      </p>

<p>[没有配置flavor的项目会有一个默认的flavor配置]</p>

<p>Projects with no flavors still have Build Variants, but the single default <code>flavor/config</code> is used, nameless, making the list of variants similar to the list of Build Types.</p>

<h4 id="product-flavor-configuration">Product Flavor Configuration</h4>

<p>Each flavors is configured with a closure:</p>

<p>```
android {
    …</p>

<pre><code>defaultConfig {
    minSdkVersion 8
    versionCode 10
}

productFlavors {
    flavor1 {
        packageName "com.example.flavor1"
        versionCode 20
    }

    flavor2 {
        packageName "com.example.flavor2"
        minSdkVersion 14
    }
} } ```
</code></pre>

<p>[ProductFlavor对象和<code>android.defaultConfig</code> 对象有相同的属性，即可以使用类似的配置方式]</p>

<p><strong>Note that the <code>android.productFlavors.*</code> objects are of type <code>ProductFlavor</code> which is the same type as the <code>android.defaultConfig</code> object. This means they share the same properties.</strong></p>

<p><code>defaultConfig</code> provides the base configuration for all flavors and each flavor can override any value. In the example above, the configurations end up being:</p>

<p>```
flavor1
packageName: com.example.flavor1
minSdkVersion: 8
versionCode: 20</p>

<p>flavor2
packageName: com.example.flavor2
minSdkVersion: 14
versionCode: 10
```</p>

<p>Usually, the Build Type configuration is an overlay over the other configuration. For instance, the Build Type’s packageNameSuffix is appended to the Product Flavor’s packageName.</p>

<p>[有些情况下，我们希望一个设置同时作用在build type和product flavor上，例如<code>signingConfig</code> 就是其中的一种配置，我们既可以设置所有的build type使用相同的SigningConfig，又可以设置某些flavor使用某个特定的SigningConfig]</p>

<p>There are cases where a setting is settable on both the Build Type and the Product Flavor. In this case, it’s is on a case by case basis.</p>

<p>For instance, <code>signingConfig</code> is one of these properties.</p>

<p>This enables either having all release packages share the same <code>SigningConfig</code>, by setting <code>android.buildTypes.release.signingConfig</code>, or have each release package use their own SigningConfig by setting each <code>android.productFlavors.*.signingConfig</code> objects separately.</p>

<h4 id="sourcesets-and-dependencies">Sourcesets and Dependencies</h4>

<p>[和build type类似，product flavor也会产生自己的sourceSets，这些sourceSets和build type的sourceSets以及<code>android.sourceSets.main</code> 组合起来构建最终的APK]</p>

<p>Similar to Build Types, Product Flavors also contribute code and resources through their own sourceSets.</p>

<p>The above example creates four sourceSets:</p>

<p><code>android.sourceSets.flavor1</code>   Location <code>src/flavor1/</code>      <br />
<code>android.sourceSets.flavor2</code>   Location <code>src/flavor2/</code>     <br />
<code>android.sourceSets.androidTestFlavor1</code>   Location <code>src/androidTestFlavor1/</code>    <br />
<code>android.sourceSets.androidTestFlavor2</code>   Location <code>src/androidTestFlavor2/</code>     </p>

<p>Those sourceSets are used to build the APK, alongside <code>android.sourceSets.main</code> and the Build Type sourceSet.</p>

<p>The following rules are used when dealing with all the sourcesets used to build a single APK:  <strong>[重点：在构建APK过程中处理所有源码和资源的规则]</strong></p>

<p>1 All source code (<code>src/*/java</code>) are used together as multiple folders generating a single output.  [所有的源代码都会整合到一起作为输出]</p>

<p>2 Manifests are all merged together into a single manifest. This allows Product Flavors to have different components and/or permissions, similarly to Build Types.  [所有的Manifest文件也都会整合成为一个Manifest文件，其中product flavor和build type类似，都可以有不同的components或者permissions]</p>

<p>3 <strong>All resources (Android <code>res</code> and <code>assets</code>) are used using overlay priority where the Build Type overrides the Product Flavor, which overrides the main sourceSet.</strong> [所有的资源文件按照优先级的不同采用覆盖的方式整合，product flavor覆盖main，build type覆盖product flavor] <strong>[?这里的优先级总觉得有点问题?]</strong></p>

<p>4 Each Build Variant generates its own <code>R</code> class (or other generated source code) from the resources. Nothing is shared between variants. [每个Build Variant都会根据它的资源文件产生一个R清单类，并且在variants之间不进行共享]</p>

<p>5 Finally, like Build Types, Product Flavors can have their own dependencies. For instance, if the flavors are used to generate a ads-based app and a paid app, one of the flavors could have a dependency on an Ads SDK, while the other does not. [最后，build type和product flavor一样都可以有自己的依赖项]</p>

<p><code>
dependencies {
    flavor1Compile "..."
}
</code></p>

<p>In this particular case, the file <code>src/flavor1/AndroidManifest.xml</code> would probably need to include the internet permission.</p>

<p>Additional sourcesets are also created for each variants:</p>

<p><code>android.sourceSets.flavor1Debug</code>   Location <code>src/flavor1Debug/</code>   <br />
<code>android.sourceSets.flavor1Release</code>   Location <code>src/flavor1Release/</code>    <br />
<code>android.sourceSets.flavor2Debug</code>    Location <code>src/flavor2Debug/</code>  <br />
<code>android.sourceSets.flavor2Release</code>    Location <code>src/flavor2Release/</code>     </p>

<p>These have higher priority than the build type sourcesets, and allow customization at the variant level.</p>

<p>[这些sourceSets的优先级比build type的sourceSets高，而且可以在variant层进行自定义]</p>

<h4 id="building-and-tasks">Building and Tasks</h4>

<p>We previously saw that each Build Type creates its own <code>assemble&lt;name&gt;</code> task, but that Build Variants are a combination of Build Type and Product Flavor.</p>

<p>[当一个product flavor被使用时，更多的assemble类型的任务会被创建，它们分别针对了特定的variant或者build type或者flavor]</p>

<p>When Product Flavors are used, more assemble-type tasks are created. These are:  </p>

<p><code>assemble&lt;Variant Name&gt;</code>    <br />
<code>assemble&lt;Build Type Name&gt;</code>        <br />
<code>assemble&lt;Product Flavor Name&gt;</code>        </p>

<p>1 allows directly building a <code>single variant</code>. For instance <code>assembleFlavor1Debug</code>.</p>

<p>2 allows building all APKs for a given <code>Build Type</code>. For instance <code>assembleDebug </code>will build both <code>Flavor1Debug</code> and <code>Flavor2Debug</code> variants.</p>

<p>3 allows building all APKs for a given <code>flavor</code>. For instance <code>assembleFlavor1</code> will build both <code>Flavor1Debug</code> and <code>Flavor1Release</code> variants.</p>

<p>The task <code>assemble</code> will build all possible variants.</p>

<h4 id="testing-1">Testing</h4>

<p>[测试包含多个<code>flavor</code> 的项目]</p>

<p>Testing multi-flavors project is very similar to simpler projects.</p>

<p>The <code>androidTest</code> sourceset is used for common tests across all flavors, while each flavor can also have its own tests.</p>

<p>As mentioned above, sourceSets to test each flavor are created:</p>

<p><code>android.sourceSets.androidTestFlavor1</code>    Location <code>src/androidTestFlavor1/</code>       <br />
<code>android.sourceSets.androidTestFlavor2</code>    Location <code>src/androidTestFlavor2/</code>      </p>

<p>Similarly, those can have their own dependencies:</p>

<p><code>
dependencies {
    androidTestFlavor1Compile "..."
}
</code></p>

<p>Running the tests can be done through the main <code>deviceCheck</code> anchor task, or the main <code>androidTest</code> tasks which acts as an anchor task when flavors are used.</p>

<p>Each flavor has its own task to run <code>tests: androidTest&lt;VariantName&gt;</code>. For instance:</p>

<p><code>androidTestFlavor1Debug</code>           <br />
<code>androidTestFlavor2Debug</code>           </p>

<p>Similarly, test APK building tasks and install/uninstall tasks are per variant:</p>

<p><code>assembleFlavor1Test</code>      <br />
<code>installFlavor1Debug</code>      <br />
<code>installFlavor1Test</code>      <br />
<code>uninstallFlavor1Debug</code>      <br />
<code>...</code></p>

<p>Finally the HTML report generation supports aggregation by flavor.
The location of the test results and reports is as follows, first for the per flavor version, and then for the aggregated one:</p>

<p><code>build/androidTest-results/flavors/&lt;FlavorName&gt;</code>      <br />
<code>build/androidTest-results/all/</code>      <br />
<code>build/reports/androidTests/flavors&lt;FlavorName&gt;</code>      <br />
<code>build/reports/androidTests/all/</code>        </p>

<p>Customizing either path, will only change the root folder and still create sub folders per-flavor and aggregated <code>results/reports</code>.</p>

<h4 id="multi-flavor-variants">Multi-flavor variants</h4>

<p>[使用<code>flavorGroups</code>，此处有些复杂，如果有这种需求请细读原文]</p>

<p>In some case, one may want to create several versions of the same apps based on more than one criteria.</p>

<p>For instance, multi-apk support in Google Play supports 4 different filters. </p>

<p>Creating different APKs split on each filter requires being able to use more than one dimension of Product Flavors.</p>

<p>Consider the example of a game that has a demo and a paid version and wants to use the ABI filter in the multi-apk support. With 3 ABIs and two versions of the application, 6 APKs needs to be generated (not counting the variants introduced by the different Build Types).</p>

<p>However, the code of the paid version is the same for all three ABIs, so creating simply 6 flavors is not the way to go.Instead, there are two dimensions of flavors, and variants should automatically build all possible combinations.</p>

<p>This feature is implemented using Flavor Groups. Each group represents a dimension, and flavors are assigned to a specific group.</p>

<p>```
android {
    …</p>

<pre><code>flavorGroups "abi", "version"

productFlavors {
    freeapp {
        flavorGroup "version"
        ...
    }

    x86 {
        flavorGroup "abi"
        ...
    }
} } ```
</code></pre>

<p>The <code>android.flavorGroups</code> array defines the possible groups, as well as the order. Each defined Product Flavor is assigned to a group.</p>

<p>From the following grouped Product Flavors <code>[freeapp, paidapp]</code> and <code>[x86, arm, mips]</code> and the <code>[debug, release]</code> Build Types, the following build variants will be created:</p>

<p><code>
x86-freeapp-debug
x86-freeapp-release
arm-freeapp-debug
arm-freeapp-release
mips-freeapp-debug
mips-freeapp-release
x86-paidapp-debug
x86-paidapp-release
arm-paidapp-debug
arm-paidapp-release
mips-paidapp-debug
mips-paidapp-release
</code></p>

<p>The order of the group as defined by <code>android.flavorGroups</code> is very important.</p>

<p>Each variant is configured by several Product Flavor objects:
<code>android.defaultConfig</code>
One from the <code>abi</code> group
One from the <code>version</code> group</p>

<p>The order of the group drives which flavor override the other, which is important for resources when a value in a flavor replaces a value defined in a lower priority flavor.</p>

<p>The flavor groups is defined with higher priority first. So in this case:
<code>abi &gt; version &gt; defaultConfig</code></p>

<p>Multi-flavors projects also have additional sourcesets, similar to the variant sourcesets but without the build type:</p>

<p><code>android.sourceSets.x86Freeapp</code>   Location <code>src/x86Freeapp/</code>       <br />
<code>android.sourceSets.armPaidapp</code>   Location <code>src/armPaidapp/</code>      <br />
<code>etc...</code></p>

<p><strong>These allow customization at the flavor-combination level. They have higher priority than the basic flavor sourcesets, but lower priority than the build type sourcesets.</strong></p>

<h3 id="advanced-build-customization">Advanced Build Customization</h3>

<h4 id="build-options">Build options</h4>

<h5 id="java-compilation-options">Java Compilation options</h5>

<p><code>
android {
    compileOptions {
        sourceCompatibility = "1.6"
        targetCompatibility = "1.6"
    }
}
</code></p>

<p>Default value is “1.6”. This affect all tasks compiling Java source code.</p>

<h5 id="aapt-options">aapt options</h5>

<p><code>
android {
    aaptOptions {
        noCompress 'foo', 'bar'
        ignoreAssetsPattern "!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir&gt;_*:!CVS:!thumbs.db:!picasa.ini:!*~"
    }
}
</code></p>

<p>This affects all tasks using aapt.</p>

<h5 id="dex-options">dex options</h5>

<p><code>
android {
    dexOptions {
        incremental false
        preDexLibraries = false
        jumboMode = false
    }
}
</code></p>

<p>This affects all tasks using dex.</p>

<h5 id="manipulating-tasks">Manipulating tasks</h5>

<p>[简单的Java项目一般都是有限的任务一起工作然后得到一个输出，例如<code>classes</code> 任务是用来编译Java源代码的任务，在<code>build.gradle</code> 文件中可以使用<code>classes</code> 来引用]</p>

<p>Basic Java projects have a finite set of tasks that all work together to create an output.</p>

<p>The <code>classes</code> task is the one that compile the Java source code.
It’s easy to access from <code>build.gradle</code> by simply using <code>classes</code> in a script. This is a shortcut for <code>project.tasks.classes</code>.</p>

<p>[但是Android项目优点复杂，因为它可能有很多相同的任务，这些任务的名称是基于build type和product flavor来生成的]</p>

<p>In Android projects, this is a bit more complicated because there could be a large number of the same task and their name is generated based on the Build Types and Product Flavors.</p>

<p>In order to fix this, the android object has two properties:</p>

<p><code>applicationVariants</code> (only for the app plugin)      <br />
<code>libraryVariants</code> (only for the library plugin)     <br />
<code>testVariants</code> (for both plugins)        </p>

<p>All three return a <code>DomainObjectCollection</code> of <code>ApplicationVariant</code>, <code>LibraryVariant</code>, and <code>TestVariant</code> objects respectively.</p>

<p>Note that accessing any of these collections will trigger the creations of all the tasks. This means no (re)configuration should take place after accessing the collections.</p>

<p>The <code>DomainObjectCollection</code> gives access to all the objects directly, or through filters which can be convenient.</p>

<p><code>
android.applicationVariants.each { variant -&gt;
    ....
}
</code></p>

<p>All three variant classes share the following properties:</p>

<p><img src="http://hujiaweibujidao.github.io/images/gradle4.png" alt="image" /></p>

<p>The ApplicationVariant class adds the following:</p>

<p><img src="http://hujiaweibujidao.github.io/images/gradle5.png" alt="image" /></p>

<p>The LibraryVariant class adds the following:</p>

<p><img src="http://hujiaweibujidao.github.io/images/gradle6.png" alt="image" /></p>

<p>The TestVariant class adds the following:</p>

<p><img src="http://hujiaweibujidao.github.io/images/gradle7.png" alt="image" /></p>

<p>API for Android specific task types.</p>

<p><img src="http://hujiaweibujidao.github.io/images/gradle8.png" alt="image" /></p>

<p><strong>The API for each task type is limited due to both <code>how Gradle works</code> and <code>how the Android plugin sets them up</code>.</strong></p>

<p>1 First, Gradle is meant to have the tasks be only configured for <code>input/output</code> location and possible optional flags. So here, the tasks only define (some of) the inputs/outputs.</p>

<p>2 Second, the input for most of those tasks is non-trivial, often coming from mixing values from the sourceSets, the Build Types, and the Product Flavors. To keep build files simple to read and understand, the goal is to let developers modify the build by tweak these objects through the DSL, rather than diving deep in the inputs and options of the tasks and changing them.</p>

<p><strong>Also note, that except for the <code>ZipAlign</code> task type, all other types require setting up <code>private data</code> to make them work. This means it’s not possible to manually create new tasks of these types.</strong></p>

<p>[除了ZipAlign任务之外，其他类型的任务都需要private data才能工作，所以没有办法manual创建这些类型的新任务]</p>

<p><strong>This API is subject to change.</strong> In general the current API is around giving access to the outputs and inputs (when possible) of the tasks to add extra processing when required). Feedback is appreciated, especially around needs that may not have been foreseen.</p>

<p>For Gradle tasks (<code>DefaultTask</code>, <code>JavaCompile</code>, <code>Copy</code>, <code>Zip</code>), refer to the Gradle documentation.</p>

<h4 id="buildtype-and-product-flavor-property-reference">BuildType and Product Flavor property reference</h4>

<p>coming soon.</p>

<p>For Gradle tasks (<code>DefaultTask</code>, <code>JavaCompile</code>, <code>Copy</code>, <code>Zip</code>), refer to the Gradle documentation.</p>

<h4 id="using-sourcecompatibility-17">Using sourceCompatibility 1.7</h4>

<p>[兼容JDK 1.7的方式，使用某些特性时还需要注意项目<code>minSdkVersion</code> 的配置]</p>

<p>With <code>Android KitKat (buildToolsVersion 19)</code> you can use the <code>diamond operator</code>, <code>multi-catch</code>, <code>strings in switches</code>, <code>try with resources</code>, etc. To do this, add the following to your build file:</p>

<p>```
android {
    compileSdkVersion 19
    buildToolsVersion “19.0.0”</p>

<pre><code>defaultConfig {
    minSdkVersion 7
    targetSdkVersion 19
}

compileOptions {
    sourceCompatibility JavaVersion.VERSION_1_7
    targetCompatibility JavaVersion.VERSION_1_7
} } ```
</code></pre>

<p>Note that you can use <code>minSdkVersion</code> with a value earlier than 19, for all language features except <code>try with resources</code>. If you want to use <code>try with resources</code>, you will need to also use a <code>minSdkVersion</code> of 19.</p>

<p>You also need to make sure that Gradle is using version 1.7 or later of the JDK. (And version 0.6.1 or later of the Android Gradle plugin.)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gradle Plugin for Android Development User Guide (1)]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2014/10/13/gradle-plugin-user-guide-1/"/>
    <updated>2014-10-13T21:00:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2014/10/13/gradle-plugin-user-guide-1</id>
    <content type="html"><![CDATA[<p>Gradle Plugin for Android Development User Guide (1)</p>

<p>终于有点时间可以学学一直打算了解的Gradle，毕竟打算以后在移动开发这条路上走到黑的话就要与时俱进，首先自然得用Google推荐的Android Studio，就目前来看，它除了还未完全支持NDK之外，很多方面都是完爆Eclipse+ADT Plugin的，而新的构建系统Gradle更是不能不了解的内容，于是找了些有用的资料开始上手看。如果你一般都是进行常规的Android SDK的开发而且对Gradle没啥兴趣的话那么直接看这篇官网教程就行了<a href="http://developer.android.com/sdk/installing/studio-build.html">http://developer.android.com/sdk/installing/studio-build.html</a>。</p>

<p>而本篇文章来自<a href="http://tools.android.com/">http://tools.android.com/</a>的<code>Gradle Plugin User Guide</code>我想应该是最好的读物了，于是细细地通读了一下，边读边注解，注意不是翻译，因为宝贵的时间有限而且原文并不难懂，所以只能是挑重要的内容注解一下，以便以后用到的时候能够更快的检索到重要信息。</p>

<p>文中标有<code>[?]</code>的地方表示我没有理解，如有理解了的或者文中有任何错误烦请留言告知，不胜感激！</p>

<p>原文地址：<a href="http://tools.android.com/tech-docs/new-build-system/user-guide">http://tools.android.com/tech-docs/new-build-system/user-guide</a></p>

<p>因为注解完之后文章变得特别长，所以分成2部分，第二部分地址：<a href="http://hujiaweibujidao.github.io/blog/2014/10/15/gradle-plugin-user-guide-2/">http://hujiaweibujidao.github.io/blog/2014/10/15/gradle-plugin-user-guide-2</a></p>

<h3 id="introduction">Introduction</h3>

<p>This documentation is for the Gradle plugin version 0.9. Earlier versions may differ due to non-compatible we are introducing before 1.0.</p>

<h3 id="goals-of-the-new-build-system">Goals of the new Build System</h3>

<p>The goals of the new build system are: </p>

<p>Make it easy to reuse code and resources     <br />
Make it easy to create several variants of an application, either for multi-apk distribution or for different flavors of an application    <br />
Make it easy to configure, extend and customize the build process   <br />
Good IDE integration    </p>

<h3 id="why-gradle">Why Gradle?</h3>

<p>Gradle is an advanced build system as well as an advanced build toolkit allowing to create custom build logic through plugins.</p>

<p>Here are some of its features that made us choose Gradle:      </p>

<p>Domain Specific Language (DSL) to describe and manipulate the build logic    <br />
Build files are Groovy based and allow mixing of declarative elements through the DSL and using code to manipulate the DSL elements to provide custom logic.    <br />
Built-in dependency management through Maven and/or Ivy.     <br />
Very flexible. Allows using best practices but doesn’t force its own way of doing things.     <br />
Plugins can expose their own DSL and their own API for build files to use.
Good Tooling API allowing IDE integration      </p>

<p>[总结起来就是：DSL(Domain Specific Language ) + Groovy based Build files + Maven/Ivy based Dependency Management + Plugin Supported]</p>

<h3 id="requirements">Requirements</h3>

<p>Gradle 1.10 or 1.11 or 1.12 with the plugin 0.11.1    <br />
SDK with Build Tools 19.0.0. Some features may require a more recent version.</p>

<h3 id="basic-project">Basic Project</h3>

<p>A Gradle project describes its build in a file called <code>build.gradle</code> located in the root folder of the project.</p>

<h4 id="simple-build-files">Simple build files</h4>

<p>The most simple Java-only project has the following <code>build.gradle</code>:</p>

<p><code>java
apply plugin: 'java'
</code></p>

<p>This applies the Java plugin, which is packaged with Gradle. The plugin provides everything to build and test Java applications.</p>

<p>The most simple Android project has the following <code>build.gradle</code>:</p>

<p>```
buildscript {
    repositories {
        mavenCentral()
    }</p>

<pre><code>dependencies {
    classpath 'com.android.tools.build:gradle:0.11.1'
} }
</code></pre>

<p>apply plugin: ‘android’</p>

<p>android {
    compileSdkVersion 19
    buildToolsVersion “19.0.0”
}
```</p>

<p>There are 3 main areas to this Android build file:</p>

<p>(1) <code>buildscript { ... }</code> configures the code driving the build.
In this case, this declares that it uses the Maven Central repository, and that there is a classpath dependency on a Maven artifact. This artifact is the library that contains the Android plugin for Gradle in version 0.11.1</p>

<p><strong>Note: This only affects the code running the build, not the project. The project itself needs to declare its own repositories and dependencies. This will be covered later.</strong></p>

<p>[注意：这里定义的repository和dependency只是build需要的，项目还需要定义自己的repository和dependency]</p>

<p>(2) Then, the android plugin is applied like the Java plugin earlier.</p>

<p>(3) Finally, <code>android { ... } </code>configures all the parameters for the android build. This is the entry point for the Android DSL.</p>

<p><strong>By default, only the compilation target, and the version of the build-tools are needed. This is done with the compileSdkVersion and buildtoolsVersion properties.</strong></p>

<p>[默认情况下，只有编译目标和编译工具的版本号是必须要给定的。以前的build系统需要在项目的根目录下的<code>project.properties</code> 文件中指定<code>target</code> (例如<code>target=android-18</code>)，它对应的就是这里的 <code>compilation target</code>，不过此处的值只是一个int值，代表Android API version]</p>

<p>The compilation target is the same as the target property in the <code>project.properties</code> file of the old build system. This new property can either be assigned a int (the api level) or a string with the same value as the previous target property.</p>

<p><strong>Important: You should only apply the android plugin. Applying the java plugin as well will result in a build error.</strong></p>

<p>[注意：这里只能使用android插件，写成java插件会出现build错误]</p>

<p>Note: You will also need a <code>local.properties</code> file to set the location of the SDK in the same way that the existing SDK requires, using the <code>sdk.dir</code> property.</p>

<p>Alternatively, you can set an environment variable called <code>ANDROID_HOME</code>. There is no differences between the two methods, you can use the one you prefer.</p>

<p>关于设置Android SDK的位置有两种方式：</p>

<p>（1）在项目根目录的<code>local.properties</code> 文件中指定<code>sdk.dir</code> 的值，如果包含ndk的话同时还要指定<code>ndk.dir</code> 的值</p>

<p><code>
sdk.dir=/Volumes/hujiawei/Users/hujiawei/Android/android_sdk
ndk.dir=/Volumes/hujiawei/Users/hujiawei/Android/android_ndk
</code>
（2）在系统中设置环境变量<code>ANDROID_HOME</code></p>

<h4 id="project-structure">Project Structure</h4>

<p>The basic build files above expect a default folder structure. Gradle follows the concept of convention over configuration, providing sensible default option values when possible.    </p>

<p>[Gradle遵循大家约定俗成的Android项目目录结构和项目配置，一个基本的项目开始时包含了两个源码集合，即main source code和test source code，它们各自的源码目录下有分别包含了Java source code和Java resource] </p>

<p>The basic project starts with two components called <code>“source sets”</code>. The main source code and the test code. These live respectively in:</p>

<p><code>
src/main/
src/androidTest/
</code></p>

<p>Inside each of these folders exists folder for each source components.
For both the Java and Android plugin, the location of the Java source code and the Java resources:</p>

<p><code>
java/
resources/
</code></p>

<p>For the Android plugin, extra files and folders specific to Android:</p>

<p><code>
AndroidManifest.xml
res/
assets/
aidl/
rs/
jni/
</code></p>

<p>Note: <code>src/androidTest/AndroidManifest.xml</code> is not needed as it is created automatically.</p>

<p>[Android插件对于Android项目还指定了一些其他的目录，注意test目录下的<code>AndroidManifest.xml</code> 文件不需要提供，因为它会自动创建，后面会提到为什么]</p>

<h4 id="configuring-the-structure">Configuring the Structure</h4>

<p>[当我们的项目原本的目录结构和上面默认的目录结构不同时，我们可以进行配置，使用<code>sourceSets</code> 节点来修改目录结构]</p>

<p>When the default project structure isn’t adequate, it is possible to configure it. According to the Gradle documentation, reconfiguring the <code>sourceSets</code> for a Java project can be done with the following:</p>

<p><code>
sourceSets {
    main {
        java {
            srcDir 'src/java'
        }
        resources {
            srcDir 'src/resources'
        }
    }
}
</code></p>

<p><strong>Note: srcDir will actually add the given folder to the existing list of source folders (this is not mentioned in the Gradle documentation but this is actually the behavior).</strong></p>

<p>[<code>srcDir</code> 会自动将给定的目录加入到默认的已有的源码目录列表中，然而<code>srcDirs</code> 会覆盖默认的源码目录设置]</p>

<p>To replace the default source folders, you will want to use <code>srcDirs</code> instead, which takes an array of path. This also shows a different way of using the objects involved:</p>

<p><code>
sourceSets {
    main.java.srcDirs = ['src/java']
    main.resources.srcDirs = ['src/resources']
}
</code></p>

<p>For more information, see the Gradle documentation on the <a href="http://www.gradle.org/docs/current/userguide/java_plugin.html">Java plugin here</a>.</p>

<p>[Android插件使用和上面相似的语法来完成配置，只不过它的<code>sourceSets</code> 节点是定义在 <code>android</code> 中的]</p>

<p>The Android plugin uses a similar syntaxes, but because it uses its own <code>sourceSets</code>, this is done within the <code>android</code> object.</p>

<p>Here’s an example, using the old project structure for the main code and remapping the <code>androidTest</code> sourceSet to the <code>tests</code> folder:</p>

<p>```
android {
    sourceSets {
        main {
            manifest.srcFile ‘AndroidManifest.xml’
            java.srcDirs = [‘src’]
            resources.srcDirs = [‘src’]
            aidl.srcDirs = [‘src’]
            renderscript.srcDirs = [‘src’]
            res.srcDirs = [‘res’]
            assets.srcDirs = [‘assets’]
        }</p>

<pre><code>    androidTest.setRoot('tests')
} } ```
</code></pre>

<p>Note: because the old structure put all source files (java, aidl, renderscript, and java resources) in the same folder, we need to remap all those new components of the sourceSet to the same src folder.</p>

<p>[<code>setRoot()</code> 会将整个sourceSet包括其中的子目录一起移动到新的目录中，这是Android插件特定的，Java插件没有此功能]</p>

<p>Note: <code>setRoot()</code> moves the whole sourceSet (and its sub folders) to a new folder. This moves <code>src/androidTest/*</code> to <code>tests/*</code></p>

<p>This is Android specific and will not work on Java sourceSets.</p>

<p>The ‘migrated’ sample shows this. [?]</p>

<h3 id="build-tasks">Build Tasks</h3>

<h4 id="general-tasks">General Tasks</h4>

<p>[使用plugin的好处是它会自动地帮我们创建一些默认的build task]</p>

<p>Applying a plugin to the build file automatically creates a set of build tasks to run. Both the Java plugin and the Android plugin do this.</p>

<p>The convention for tasks is the following: [下面是默认的build tasks]</p>

<p><code>assemble</code>   The task to assemble the output(s) of the project     <br />
<code>check</code>   The task to run all the checks.     <br />
<code>build</code>   This task does both assemble and check    <br />
<code>clean</code>    This task cleans the output of the project        </p>

<p><strong>[任务assemble，check，build实际上什么都没有做，它们只是anchor task，需要添加实际的task它们才知道如何工作，这样的话就可以不管你是什么类型的项目都可以调用相同名称的build task。例如如果使用了<code>findbugs</code> 插件的话，它会自动创建一个新的task，而且check task会依赖它，也就有是说，每当check task执行的时候，这个新的task都会被调用而执行]</strong></p>

<p><strong>The tasks assemble, check and build don’t actually do anything. They are anchor tasks for the plugins to add actual tasks that do the work.</strong></p>

<p>This allows you to always call the same task(s) no matter what the type of project is, or what plugins are applied.</p>

<p>For instance, applying the <code>findbugs</code> plugin will create a new task and make <code>check</code> depend on it, making it be called whenever the <code>check</code> task is called.</p>

<p>From the command line you can get the high level task running the following command:   <code>gradle tasks</code>    <br />
For a full list and seeing dependencies between the tasks run:  <code>gradle tasks --all</code></p>

<p>[在Android Studio的Terminal中运行结果如下]</p>

<p><img src="http://hujiaweibujidao.github.io/images/gradle1.png" alt="image" /></p>

<p>Note: Gradle automatically monitor the declared inputs and outputs of a task. Running the build twice without change will make Gradle report all tasks as UP-TO-DATE, meaning no work was required. This allows tasks to properly depend on each other without requiring unneeded build operations. </p>

<p><strong>[Gradle会监视一个任务的输入和输出，重复运行build结果都没有变化的话Gradle会提示所有的任务都是UP-TO-DATE，这样可以避免不必要的build操作]</strong></p>

<h4 id="java-project-tasks">Java project tasks</h4>

<p>[Java插件主要创建了两个新的task，其中<code>jar</code> task是<code>assemble</code> task的依赖项，<code>test</code> task是<code>check</code> task的依赖项]</p>

<p>The Java plugin creates mainly two tasks, that are dependencies of the main anchor tasks:</p>

<p><code>assemble</code>  -&gt;   <code>jar</code>   This task creates the output.     <br />
<code>check</code>  -&gt;    <code>test</code>  This task runs the tests.       </p>

<p><strong>[任务jar直接或者间接地依赖其他的任务，例如用来编译Java代码的任务<code>classes</code>； 测试代码是由<code>testClasses</code> 任务来编译的，但是你不需要去调用这个task，因为<code>test</code> 任务依赖于<code>testClasses</code> 和 <code>classes</code> 任务]</strong></p>

<p>The <code>jar</code> task itself will depend directly and indirectly on other tasks: <code>classes</code> for instance will compile the Java code. </p>

<p>** The tests are compiled with <code>testClasses</code>, but it is rarely useful to call this as <code>test</code> depends on it (as well as <code>classes</code>). **</p>

<p>In general, you will probably only ever call <code>assemble</code> or <code>check</code>, and ignore the other tasks.</p>

<p>You can see the full set of tasks and their descriptions for the <a href="http://gradle.org/docs/current/userguide/java_plugin.html">Java plugin here</a>.</p>

<h4 id="android-tasks">Android tasks</h4>

<p>The Android plugin use the same convention to stay compatible with other plugins, and adds an additional anchor task:</p>

<p><code>assemble</code>    The task to assemble the output(s) of the project      <br />
<code>check</code>   The task to run all the checks.          <br />
<code>connectedCheck</code>   Runs checks that requires a connected device or emulator, they will run on all connected devices in parallel. <strong>[在已连接的设备和模拟器上并行运行check任务]</strong>              <br />
<code>deviceCheck</code>   Runs checks using APIs to connect to remote devices. This is used on CI servers.  <strong>[使用APIs来连接远程设备以运行check任务]</strong>                         <br />
<code>build</code>   This task does both assemble and check     <br />
<code>clean</code>    This task cleans the output of the project</p>

<p>The new anchor tasks are necessary in order to be able to run regular checks without needing a connected device.Note that build does not depend on deviceCheck, or connectedCheck.</p>

<p><strong>[任务build并不依赖deviceCheck和connectedCheck这两个任务]</strong></p>

<p>An Android project has at least two outputs: a debug APK and a release APK. Each of these has its own anchor task to facilitate building them separately:</p>

<p>[Android项目至少有两个输出：一个debug模式的APK，另一个是release模式deAPK，每种模式都有自己的anchor task以便于将它们的build过程分开]</p>

<p><code>assemble</code>   <br />
<code>assembleDebug</code>    <br />
<code>assembleRelease</code>     </p>

<p>They both depend on other tasks that execute the multiple steps needed to build an APK. The <code>assemble</code> task depends on both, so calling it will build both APKs.</p>

<p><strong>Tip: Gradle support camel case shortcuts for task names on the command line.</strong> </p>

<p>[Gradle支持在命令行中使用某个task的名称的camel case缩写调用这个task]</p>

<p>For instance:   <code>gradle aR</code>  is the same as typing  <code>gradle assembleRelease</code>，as long as no other task match <code>‘aR’</code></p>

<p>The <code>check</code> anchor tasks have their own dependencies:</p>

<p><code>check</code>      <br />
<code>lint</code>    <br />
<code>connectedCheck</code>    <br />
<code>connectedAndroidTest</code>    <br />
<code>connectedUiAutomatorTest </code>(not implemented yet)    <br />
<code>deviceCheck</code>      </p>

<p>This depends on tasks created when other plugins implement test extension points.</p>

<p><strong>Finally, the plugin creates <code>install/uninstall</code> tasks for all build types (debug, release, test), as long as they can be installed (which requires signing).</strong></p>

<p>[Android插件还会对所有build type创建它们的<code>install/uninstall</code> 任务，只要它们可以被安装，安装需要签名]</p>

<h3 id="basic-build-customization">Basic Build Customization</h3>

<p>The Android plugin provides a broad DSL to customize most things directly from the build system.</p>

<h4 id="manifest-entries">Manifest entries</h4>

<p>[通过DSL我们可以在<code>build.gradle</code> 文件中指定那些定义在AndroidManifest文件中的内容，不过能够指定的内容有限]</p>

<p>Through the DSL it is possible to configure the following manifest entries:</p>

<p><code>minSdkVersion</code>    <br />
<code>targetSdkVersion</code>   <br />
<code>versionCode</code>   <br />
<code>versionName</code>   <br />
<code>applicationId</code> (the effective packageName – see <a href="http://tools.android.com/tech-docs/new-build-system/applicationid-vs-packagename">ApplicationId versus PackageName</a> for more information)    <br />
<code>Package Name</code> for the test application   <br />
<code>Instrumentation test runner</code>     </p>

<p>Example:</p>

<p>```
android {
    compileSdkVersion 19
    buildToolsVersion “19.0.0”</p>

<pre><code>defaultConfig {
    versionCode 12
    versionName "2.0"
    minSdkVersion 16
    targetSdkVersion 16
} } ```
</code></pre>

<p>The <code>defaultConfig</code> element inside the android element is where all this configuration is defined.</p>

<p><strong>Previous versions of the Android Plugin used <code>packageName</code> to configure the manifest ‘packageName’ attribute. Starting in 0.11.0, you should use <code>applicationId</code> in the <code>build.gradle</code> to configure the manifest ‘packageName’ entry. This was disambiguated to reduce confusion between the application’s packageName (which is its ID) and java packages.</strong></p>

<p>[从Gradle Plugin 0.11.0 版本开始在<code>build.gradle</code> 文件中使用<code>applicationId</code> 而不是 <code>packageName</code> 来指定AndroidManifest文件中的<code>packageName</code>]</p>

<p>The power of describing it in the build file is that it can be dynamic.
For instance, one could be reading the version name from a file somewhere or using some custom logic:</p>

<p>[将上面那些内容定义在build文件中的魔力就在于它们可以是动态的，如下所示]</p>

<p>```
def computeVersionName() {
    …
}</p>

<p>android {
    compileSdkVersion 19
    buildToolsVersion “19.0.0”</p>

<pre><code>defaultConfig {
    versionCode 12
    versionName computeVersionName()
    minSdkVersion 16
    targetSdkVersion 16
} } ```
</code></pre>

<p>[注意不要使用当前域中已有的getter方法作为自定义的函数名，否则会发生冲突]</p>

<p><strong>Note: Do not use function names that could conflict with existing getters in the given scope. For instance instance <code>defaultConfig { ...}</code> calling <code>getVersionName()</code> will automatically use the getter of <code>defaultConfig.getVersionName()</code> instead of the custom method.</strong></p>

<p>If a property is not set through the DSL, some default value will be used. Here’s a table of how this is processed.</p>

<p><img src="http://hujiaweibujidao.github.io/images/gradle2.png" alt="image" /></p>

<p><strong>[第2列是当你在build script中使用自定义逻辑去查询第1列元素对应的默认结果，如果结果不是你想要的话，你可以指定另一个结果，但是在build时如果这个结果是null的话，build系统就会使用第3列中的结果]</strong></p>

<p>The value of the 2nd column is important if you use custom logic in the build script that queries these properties. For instance, you could write:</p>

<p><code>
if (android.defaultConfig.testInstrumentationRunner == null) {
    // assign a better default...
}
</code></p>

<p>If the value remains null, then it is replaced at build time by the actual default from column 3, but the DSL element does not contain this default value so you can’t query against it.</p>

<p>This is to prevent parsing the manifest of the application unless it’s really needed. </p>

<h4 id="build-types">Build Types</h4>

<p>[默认情况下，Android插件会自动将原项目编译成debug和release两个版本，它们的区别在于调试程序的功能和APK的签名方式。debug版本使用<code>key/certificate</code> 来签名，而release版本在build过程中并不签名，它的签名过程发生在后面。Android插件允许我们自定义build type]</p>

<p>By default, the Android plugin automatically sets up the project to build both a debug and a release version of the application.</p>

<p><strong>These differ mostly around the ability to debug the application on a secure (non dev) devices, and how the APK is signed.</strong></p>

<p><strong>The debug version is signed with a <code>key/certificate</code> that is created automatically with a known <code>name/password</code> (to prevent required prompt during the build). The release is not signed during the build, this needs to happen after.</strong></p>

<p>This configuration is done through an object called a <code>BuildType</code>. By default, 2 instances are created, a <code>debug</code> and a <code>release</code> one.</p>

<p>The Android plugin allows customizing those two instances as well as creating other Build Types. This is done with the <code>buildTypes</code> DSL container:</p>

<p>```
android {
    buildTypes {
        debug {
            applicationIdSuffix “.debug”
        }</p>

<pre><code>    jnidebug.initWith(buildTypes.debug)
    jnidebug {
        packageNameSuffix ".jnidebug"
        jnidebugBuild true
    }
} } ```
</code></pre>

<p>The above snippet achieves the following:</p>

<p>Configures the default debug Build Type:</p>

<p>(1) set its package to be <code>&lt;app appliationId&gt;.debug</code> to be able to install both debug and release apk on the same device</p>

<p>(2) Creates a new BuildType called jnidebug and configure it to be a copy of the debug build type.</p>

<p>(3) Keep configuring the jnidebug, by enabling debug build of the JNI component, and add a different package suffix.</p>

<p>[在buildTypes容器中创建一个新的build type很简单，要么调用<code>initWith()</code> 方法继承自某个build type或者直接使用花括号来配置它]</p>

<p>Creating new Build Types is as easy as using a new element under the buildTypes container, either to call <code>initWith()</code> or to configure it with a closure.</p>

<p>The possible properties and their default values are:</p>

<p><img src="http://hujiaweibujidao.github.io/images/gradle3.png" alt="image" /></p>

<p>In addition to these properties, Build Types can contribute to the build with code and resources.</p>

<p><strong>[对于每个build type都会生成一个对应的<code>sourceSet</code>，默认的位置是<code>src/&lt;buildtypename&gt;/</code> ，所以build type的名称不能是<code>main</code>或者<code>androidTest</code>，而且它们相互之间不能重名]</strong></p>

<p>For each Build Type, a new matching <code>sourceSet</code> is created, with a default location of  <code>src/&lt;buildtypename&gt;/</code></p>

<p>This means the Build Type names cannot be main or androidTest (this is enforced by the plugin), and that they have to be unique to each other.</p>

<p>Like any other source sets, the location of the build type source set can be relocated:</p>

<p><code>
android {
    sourceSets.jnidebug.setRoot('foo/jnidebug')
}
</code></p>

<p>[类似其他的sourceSet，build type的source set的位置也可以重新定义，此外，对于每个build type，都会自动创建一个名为<code>assemble&lt;BuildTypeName&gt;</code> 的任务，而且自动称为<code>assemble</code> 任务的依赖项]</p>

<p>Additionally, for each Build Type, a new <code>assemble&lt;BuildTypeName&gt;</code> task is created.</p>

<p>The <code>assembleDebug</code> and <code>assembleRelease</code> tasks have already been mentioned, and this is where they come from. When the debug and release Build Types are pre-created, their tasks are automatically created as well.</p>

<p>The <code>build.gradle</code> snippet above would then also generate an <code>assembleJnidebug</code> task, and <code>assemble</code> would be made to depend on it the same way it depends on the <code>assembleDebug</code> and <code>assembleRelease</code> tasks.</p>

<p>Tip: remember that you can type gradle aJ to run the assembleJnidebug task.</p>

<p>Possible use case: [使用场景]</p>

<p>Permissions in debug mode only, but not in release mode    <br />
Custom implementation for debugging   <br />
Different resources for debug mode (for instance when a resource value is tied to the signing certificate).      </p>

<p><strong>[build type的code/resources的处理过程: (1)Manifest整合进app的Manifest; (2)code就作为另一个源码目录; (3)resources覆盖原有的main resources]</strong></p>

<p>The code/resources of the BuildType are used in the following way:</p>

<p>The manifest is merged into the app manifest    <br />
The code acts as just another source folder   <br />
The resources are overlayed over the main resources, replacing existing values.</p>

<h4 id="signing-configurations">Signing Configurations</h4>

<p>Signing an application requires the following: </p>

<p>A keystore    <br />
A keystore password   <br />
A key alias name   <br />
A key password   <br />
The store type     </p>

<p>The location, as well as the key name, both passwords and store type form together a Signing Configuration (type <code>SigningConfig</code>)     </p>

<p><strong>[对一个应用程序进行签名需要5个信息，这些信息组合起来就是类型SigningConfig。默认情况下，debug的配置使用了一个已知密码的keystore和已知密码的默认key，其中的keystore保存在<code>$HOME/.android/debug.keystore</code> 文件中，如果没有的话它会自动被创建]</strong></p>

<p>By default, there is a <code>debug</code> configuration that is setup to use a debug keystore, with a known password and a default key with a known password.The debug keystore is located in <code>$HOME/.android/debug.keystore</code>, and is created if not present.</p>

<p>The debug Build Type is set to use this debug SigningConfig automatically.It is possible to create other configurations or customize the default built-in one. This is done through the signingConfigs DSL container:</p>

<p>[默认情况下，debug的build过程会自动使用debug SigningConfig，当然我们可以自己定义]</p>

<p>```
android {
    signingConfigs {
        debug {
            storeFile file(“debug.keystore”)
        }</p>

<pre><code>    myConfig {
        storeFile file("other.keystore")
        storePassword "android"
        keyAlias "androiddebugkey"
        keyPassword "android"
    }
}

buildTypes {
    foo {
        debuggable true
        jniDebugBuild true
        signingConfig signingConfigs.myConfig
    }
} } ```
</code></pre>

<p>The above snippet changes the location of the debug keystore to be at the root of the project. This automatically impacts any Build Types that are set to using it, in this case the debug Build Type.</p>

<p>It also creates a new Signing Config and a new Build Type that uses the new configuration.</p>

<p><strong>[只有当debug keystore是放在默认的位置，即使修改了keystore文件的名称，keystore也会被自动创建，但是如果改变了默认位置的话则不会被自动创建。此外，设置keystore的位置一般使用相对于项目根目录的路径，虽然也可以使用绝对路径，但是并不推荐这样做]</strong></p>

<p>Note: Only debug keystores located in the default location will be automatically created. Changing the location of the debug keystore will not create it on-demand. Creating a SigningConfig with a different name that uses the default debug keystore location will create it automatically. In other words, it’s tied to the location of the keystore, not the name of the configuration.</p>

<p>Note: Location of keystores are usually relative to the root of the project, but could be absolute paths, though it is not recommended (except for the debug one since it is automatically created).</p>

<p>Note:  If you are checking these files into version control, you may not want the password in the file. The following Stack Overflow post shows ways to read the values from the console, or from environment variables.
http://stackoverflow.com/questions/18328730/how-to-create-a-release-signed-apk-file-using-gradle</p>

<p>We’ll update this guide with more detailed information later.</p>

<h4 id="running-proguard">Running ProGuard</h4>

<p>[对ProGuard的支持是通过Gradle plugin for ProGuard 4.10来实现的，给build type添加<code>runProguard</code> 属性即可自动生成相应的task]</p>

<p>ProGuard is supported through the Gradle plugin for ProGuard version 4.10. </p>

<p>The ProGuard plugin is applied automatically, and the tasks are created automatically if the Build Type is configured to run ProGuard through the <code>runProguard</code> property.</p>

<p>```
android {
    buildTypes {
        release {
            runProguard true
            proguardFile getDefaultProguardFile(‘proguard-android.txt’)
        }
    }</p>

<pre><code>productFlavors {
    flavor1 {
    }
    flavor2 {
        proguardFile 'some-other-rules.txt'
    }
} } ```
</code></pre>

<p>Variants use all the rules files declared in their build type, and product flavors.</p>

<p><strong>[默认情况下有两个proguard rule 文件，它们存放在Android SDK目录中，默认是<code>$ANDROID_HOME/tools/proguard/</code> 目录下 ，使用<code>getDefaultProguardFile()</code> 可以得到它们的完整路径]</strong></p>

<p>There are 2 default rules files </p>

<p><code>proguard-android.txt</code>     <br />
<code>proguard-android-optimize.txt</code>        </p>

<p>They are located in the SDK. Using <code>getDefaultProguardFile()</code> will return the full path to the files. They are identical except for enabling optimizations.</p>

<h3 id="dependencies-android-libraries-and-multi-project-setup">Dependencies, Android Libraries and Multi-project setup</h3>

<p>Gradle projects can have dependencies on other components. These components can be external binary packages, or other Gradle projects.</p>

<h4 id="dependencies-on-binary-packages">Dependencies on binary packages</h4>

<h4 id="local-packages">Local packages</h4>

<p>To configure a dependency on an external library jar, you need to add a dependency on the <code>compile</code> configuration.</p>

<p>```
dependencies {
    compile files(‘libs/foo.jar’)
}</p>

<p>android {
    …
}
```</p>

<p>[注意dependencies是标准Gradle API的一部分，所以不是在android元素中声明]</p>

<p><strong>Note: the dependencies DSL element is part of the standard Gradle API and does not belong inside the android element.</strong></p>

<p>[<code>compile</code> 的配置是用来编译main application的，所以其中的所有元素都会加入到编译的类路径中，同样也会打包进最终的APK中]</p>

<p><strong>The <code>compile</code> configuration is used to compile the main application. Everything in it is added to the compilation classpath and also packaged in the final APK.</strong></p>

<p>There are other possible configurations to add dependencies to:</p>

<p><code>compile</code>: main application     <br />
<code>androidTestCompile</code>: test application    <br />
<code>debugCompile</code>: debug Build Type    <br />
<code>releaseCompile</code>: release Build Type.      </p>

<p><strong>[对应每个build type都有一个对应的<code>&lt;buildtype&gt;Compile</code>， 它们的dependencies也都可以自行定义使其不同。如果希望不同的build type表现出不同的结果时，我们便可以使用这种方式让它们依赖不同的library]</strong></p>

<p>Because it’s not possible to build an APK that does not have an associated Build Type, the APK is always configured with two (or more) configurations: <code>compile</code> and <code>&lt;buildtype&gt;Compile</code>.</p>

<p>Creating a new Build Type automatically creates a new configuration based on its name.</p>

<p>This can be useful if the debug version needs to use a custom library (to report crashes for instance), while the release doesn’t, or if they rely on different versions of the same library.</p>

<h4 id="remote-artifacts">Remote artifacts</h4>

<p>[Gradle支持Maven和Ivy资源库]</p>

<p>Gradle supports pulling artifacts from Maven and Ivy repositories.</p>

<p>First the repository must be added to the list, and then the dependency must be declared in a way that Maven or Ivy declare their artifacts.</p>

<p>```
repositories {
    mavenCentral()
}</p>

<p>dependencies {
    compile ‘com.google.guava:guava:11.0.2’
}</p>

<p>android {
    …
}
```</p>

<p><strong>[<code>mavenCentral()</code> 方法返回的就是Maven Repository的URL，Gradle同时支持remote 和 local repositories，此外，Gradle能够处理dependency之间的相互依赖，然后自动pull所需要的dependencies]</strong></p>

<p>Note: <code>mavenCentral()</code> is a shortcut to specifying the URL of the repository. Gradle supports both remote and local repositories.</p>

<p>Note: Gradle will follow all dependencies transitively. This means that if a dependency has dependencies of its own, those are pulled in as well.</p>

<p>For more information about setting up dependencies, read the <a href="http://gradle.org/docs/current/userguide/artifact_dependencies_tutorial.html">Gradle user guide here</a>, and <a href="http://gradle.org/docs/current/dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html">DSL documentation here</a>.</p>

<h4 id="multi-project-setup">Multi project setup</h4>

<p>[使用multi-project setup可以使得Gradle项目依赖其他的Gradle项目，它通常是通过将所有的项目作为某个指定的根项目的子目录来实现的。]</p>

<p>Gradle projects can also depend on other gradle projects by using a multi-project setup.</p>

<p>A multi-project setup usually works by having all the projects as sub folders of a given root project.</p>

<p>For instance, given to following structure:</p>

<p><code>
MyProject/
 + app/
 + libraries/
    + lib1/
    + lib2/
</code></p>

<p>We can identify 3 projects. Gradle will reference them with the following name:</p>

<p><code>
:app
:libraries:lib1
:libraries:lib2
</code></p>

<p><strong>Each projects will have its own <code>build.gradle</code> declaring how it gets built. Additionally, there will be a file called <code>settings.gradle</code> at the root declaring the projects.</strong></p>

<p>[每个项目都有自己的<code>build.gradle</code> 文件声明它的build过程，此外，根项目下还有一个<code>settings.gradle</code> 文件用来指定这些子项目]</p>

<p>This gives the following structure:</p>

<p><code>
MyProject/
 | settings.gradle
 + app/
    | build.gradle
 + libraries/
    + lib1/
       | build.gradle
    + lib2/
       | build.gradle
</code></p>

<p>The content of <code>settings.gradle</code> is very simple:</p>

<p><code>
include ':app', ':libraries:lib1', ':libraries:lib2'
</code></p>

<p>This defines which folder is actually a Gradle project. [它声明了哪个目录是一个Gradle项目]</p>

<p>The <code>:app</code> project is likely to depend on the libraries, and this is done by declaring the following dependencies:</p>

<p><code>
dependencies {
    compile project(':libraries:lib1')
}
</code></p>

<p>More general information about <a href="http://gradle.org/docs/current/userguide/multi_project_builds.html">multi-project setup here</a>.</p>

<h4 id="library-projects">Library projects</h4>

<p><strong>[如果前面例子中的两个library projects都是Java项目的话，那么app这个Android项目就使用它们的输出jar文件即可，但是如果你需要引用library project中的资源或者代码的话，那它们必须是Android Library Projects]</strong></p>

<p>In the above multi-project setup, <code>:libraries:lib1</code> and <code>:libraries:lib2</code> can be Java projects, and the <code>:app</code> Android project will use their jar output.</p>

<p>However, if you want to share code that accesses Android APIs or uses Android-style resources, these libraries cannot be regular Java project, they have to be <code>Android Library Projects</code>.</p>

<h4 id="creating-a-library-project">Creating a Library Project</h4>

<p>A Library project is very similar to a regular Android project with a few differences.</p>

<p>Since building libraries is different than building applications, a different plugin is used. Internally both plugins share most of the same code and they are both provided by the same <code>com.android.tools.build.gradle</code> jar.</p>

<p><strong>[创建Library Project使用的是不同的插件，即<code>android-library</code>，它和<code>android</code> 插件共享很多的代码(所以大部分的配置都和前面提到的一模一样)，并且这个插件的源码也是在<code>com.android.tools.build.gradle</code> 这个jar包中]</strong></p>

<p>```
buildscript {
    repositories {
        mavenCentral()
    }</p>

<pre><code>dependencies {
    classpath 'com.android.tools.build:gradle:0.5.6'
} }
</code></pre>

<p>apply plugin: ‘android-library’</p>

<p>android {
    compileSdkVersion 15
}
```</p>

<p>This creates a library project that uses API 15 to compile. SourceSets, and dependencies are handled the same as they are in an application project and can be customized the same way.</p>

<h4 id="differences-between-a-project-and-a-library-project">Differences between a Project and a Library Project</h4>

<p><strong>[一个Library Project的主要输出是一个aar包，它是编译后的代码与资源的集合，它同样可以生成test apk来独立地测试这个library。Library Project和普通Project的assemble task是一样的，所以它们的behave没啥区别。此外，因为它可以有不同的build type和product flavor，所以它可以得到很多个不同的aar]</strong></p>

<p>A Library project’s main output is an .aar package (which stands for Android archive). It is a combination of compile code (as a jar file and/or native .so files) and resources (manifest, res, assets).</p>

<p>**A library project can also generate a test apk to test the library independently from an application. **</p>

<p>The same anchor tasks are used for this (<code>assembleDebug</code>, <code>assembleRelease</code>) so there’s no difference in commands to build such a project.</p>

<p>For the rest, libraries behave the same as application projects. <strong>They have build types and product flavors, and can potentially generate more than one version of the aar.</strong></p>

<p>[大多数的build type的配置都不会应用于Library Project中，当然它还是可以进行配置的]</p>

<p><strong>Note that most of the configuration of the Build Type do not apply to library projects. However you can use the custom sourceSet to change the content of the library depending on whether it’s used by a project or being tested.</strong></p>

<h4 id="referencing-a-library">Referencing a Library</h4>

<p>Referencing a library is done the same way any other project is referenced:</p>

<p><code>
dependencies {
    compile project(':libraries:lib1')
    compile project(':libraries:lib2')
}
</code></p>

<p>Note: if you have more than one library, then the order will be important. This is similar to the old build system where the order of the dependencies in the <code>project.properties</code> file was important.  </p>

<p>[注：如果你有很多的library projects，那么你要根据它们相互之间的依赖关系确定一个正确的顺序，就类似以前build系统中的<code>project.properties</code> 文件一样，以前需要如下地声明<code>android.library.reference</code>]</p>

<p><code>
android.library.reference.1=path/to/libraryproject
</code></p>

<h4 id="library-publication">Library Publication</h4>

<p>[默认情况下，library project只会publish它的release variant，所有其他的project都是引用这个variant，但是你还是可以通过配置<code>defaultPublishConfig</code> 控制将哪个variant进行publish，而且你也可以设置为publish所有variant]</p>

<p>By default a library only publishes its release variant. This variant will be used by all projects referencing the library, no matter which variant they build themselves. This is a temporary limitation due to Gradle limitations that we are working towards removing.</p>

<p>You can control which variant gets published with </p>

<p><code>
android {
    defaultPublishConfig "debug"
}
</code></p>

<p>**Note that this publishing configuration name references the full variant name. Release and debug are only applicable when there are no flavors. ** If you wanted to change the default published variant while using flavors, you would write:</p>

<p><code>
android {
    defaultPublishConfig "flavor1Debug"
}
</code></p>

<p><strong>It is also possible to publish all variants of a library. We are planning to allow this while using a normal project-to-project dependency (like shown above), but this is not possible right now due to limitations in Gradle (we are working toward fixing those as well).</strong></p>

<p>Publishing of all variants are not enabled by default. To enable them:</p>

<p><code>
android {
    publishNonDefault true
}
</code></p>

<p>It is important to realize that publishing multiple variants means publishing multiple aar files, instead of a single aar containing multiple variants. Each aar packaging contains a single variant.</p>

<p>[publish一个variant意味着使得这个aar包作为Gradle项目的输出，它可以用于publish到maven repository，也可以被其他项目作为依赖项目被引用]</p>

<p><strong>Publishing an variant means making this aar available as an output artifact of the Gradle project. This can then be used either when publishing to a maven repository, or when another project creates a dependency on the library project.</strong></p>

<p>Gradle has a concept of default” artifact. This is the one that is used when writing:</p>

<p><code>
compile project(':libraries:lib2')
</code></p>

<p>To create a dependency on another published artifact, you need to specify which one to use:</p>

<p><code>
dependencies {
    flavor1Compile project(path: ':lib1', configuration: 'flavor1Release')
    flavor2Compile project(path: ':lib1', configuration: 'flavor2Release')
}
</code></p>

<p>Important: Note that the published configuration is a full variant, including the build type, and needs to be referenced as such. </p>

<p><strong>Important: When enabling publishing of non default, the Maven publishing plugin will publish these additional variants as extra packages (with classifier). This means that this is not really compatible with publishing to a maven repository. You should either publish a single variant to a repository OR enable all config publishing for inter-project dependencies.</strong> [?]</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Material on Mobile Development]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2014/03/13/mobile-development-materials/"/>
    <updated>2014-03-13T20:28:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2014/03/13/mobile-development-materials</id>
    <content type="html"><![CDATA[<h3 id="android">Android部分</h3>

<h5 id="section">(1)网站类</h5>

<p>1.Android开发者：<a href="http://developer.android.com/index.html">http://developer.android.com/index.html</a>    </p>

<p>Google官方Android开发者网站，发布关于Android的最新信息，有最权威的<a href="http://developer.android.com/training/index.html">开发教程</a>和<a href="http://developer.android.com/guide/components/index.html">API手册</a>以及<a href="http://developer.android.com/design/index.html">应用设计教程</a>，还提供最新最强大的<a href="http://developer.android.com/tools/index.html">开发工具以及SDK</a>下载！    </p>

<p>2.开源中国 Android开发专区：<a href="http://www.oschina.net/android">http://www.oschina.net/android</a></p>

<p>这里有关于Android开发的各种知识，小到环境搭建，大到细节实现，很多开发者在这里分享了自己的开发经验，所以如果在某个方面遇到了问题，没准可以在这里找到答案。</p>

<p>3.其他资源</p>

<p><a href="http://stackoverflow.com/">StackOverflow</a> 嘿嘿，没有它解决不了的问题！</p>

<p><a href="http://blog.daimajia.com/?page_id=60">Android 开源资料库</a>  开源资料不少，大部分都在Github上</p>

<h5 id="section-1">(2)书籍类</h5>

<p>1.<a href="http://book.douban.com/subject/6515839/">《疯狂Android讲义》</a></p>

<p>作者李刚，国内的Java领域大牛之一，著有多本疯狂系列的书籍，包括<a href="http://book.douban.com/subject/3246499/">《疯狂Java讲义》</a>、<a href="http://book.douban.com/subject/3333726/">《轻量级Java EE企业应用实战(第3版):Struts 2＋Spring 3＋Hibernate整合开发》</a>等等。
《疯狂Android讲义》这本书很厚，基本上覆盖了Android开发的所有内容，作者凭借丰富的教学经验对Android开发进行讲解，对于初学者可能遇到的各种问题和各种疑惑都意义进行了分析，内容足够深入，另外，此书还有几个实例项目进行实践，可以说，学习Android开发有这一本书足够了！如果感觉Java基础不足了，推荐看他的另一本Java巨著<a href="http://book.douban.com/subject/6515839/">《疯狂Java讲义》</a>，同样，学习Java只要看这本书就足够了！当然，最好还是看下<a href="http://book.douban.com/subject/2130190/">《Java编程思想》</a></p>

<p>2.其他书籍</p>

<p>[入门篇]人民邮电出版社：
<a href="http://book.douban.com/subject/3770255/">《Google Android开发入门与实战》</a>
<a href="http://book.douban.com/subject/3788013/">《Google Android SDK开发范例大全》</a></p>

<p>两本都是入门级别的书籍，而且两本时间有点早了，如果有新版本建议看新版本</p>

<p>[提高篇]电子工业出版社：
<a href="http://book.douban.com/subject/4251755/">《Android系统原理及开发要点详解》</a>
<a href="http://book.douban.com/subject/5907455/">《Android系统级深入开发》</a></p>

<p>两本书是同样两位作者写的，写的时间比较早了，内容不是很新鲜，但是还是很有参考价值，因为内容涉及到系统原理，所以并不简单，适合想了解系统原理，但是又不想精读系统原理</p>

<p>[深入篇]机械工业出版社：<a href="http://book.douban.com/subject/6802440/">《深入理解Android(卷一)》</a><a href="http://book.douban.com/subject/11542973/">《深入理解Android(卷二)》</a> </p>

<p>作者邓凡平，深入理解Android姊妹篇，经典中的经典，对于深入理解Android很有帮助，两本书以源码分析的方式介绍Android了各个子系统，灰常深入，适合想精通系统原理 [这两本书我还没看]</p>

<p>如果真的想要深入Android系统原理的话不妨看下<a href="http://blog.csdn.net/luoshengyang/article/details/8923485">老罗是怎么做到的</a>，嘿嘿</p>

<p>其他的好书：     </p>

<p><a href="http://book.douban.com/subject/20556210/">《Android软件安全与逆向分析》</a></p>

<p><a href="http://book.douban.com/subject/6047744/">《Android技术内幕》</a></p>

<p><a href="http://book.douban.com/subject/19994024/">50 Android Hacks</a></p>

<p><a href="http://www.amazon.cn/s/ref=nb_sb_noss?__mk_zh_CN=%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%BD%91%E7%AB%99&amp;url=search-alias%3Dstripbooks&amp;field-keywords=%E5%9B%BE%E7%81%B5%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%9B%E4%B9%A6%E2%80%A2%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97+android&amp;rh=n%3A658390051%2Ck%3A%E5%9B%BE%E7%81%B5%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%9B%E4%B9%A6%E2%80%A2%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97+android">图灵程序设计丛书•移动开发系列 Android</a>   </p>

<p>图灵系列的书籍都是灰常的经典，一本本都是好书，但是一个人时间精力有限，难以都看完，再加上这些书籍中的很多内容是重叠了的，所以要根据自己实际的开发需求来读相应的书籍</p>

<p>如果是进行Android NDK开发的话，推荐两本书籍：</p>

<p><a href="http://book.douban.com/subject/20285069/">《Pro Android C++ with the NDK》</a> <a href="http://book.douban.com/subject/20469441/">《Mastering OpenCV with Practical Computer Vision Projects》</a> </p>

<h4 id="android-1">Android学习总结：先专注于某本入门书籍，细读它，理解大部分内容，如果原书有源码，建议实际运行看下结果，如果原书有项目实践，建议跟着作者的步骤一步步完成。另外，读书建议先粗略读，然后细读，这样前面不懂的小知识马上就解决了，不用花时间纠缠于某个小问题，要提高读书效率。读完了入门级书之后建议自己找个项目做做，可以是小游戏，也可以是小应用，然后开始看提高篇或者深入篇的书籍。</h4>

<hr />

<h3 id="ios">iOS部分</h3>

<h5 id="section-2">(1)网站类</h5>

<p>1.Apple iOS Dev Center：<a href="https://developer.apple.com/devcenter/ios/index.actions">https://developer.apple.com/devcenter/ios/index.action</a></p>

<p>苹果官方iOS开发网址，最新的资讯、教程、开发工具</p>

<p>2.开源中国 iOS专区：<a href="http://www.oschina.net/ios/home">http://www.oschina.net/ios/home</a></p>

<p>丰富的开发教程和开发资源，遇到什么问题可以在这里找找教程</p>

<p>3.Cocoa China：<a href="http://www.cocoachina.com/">http://www.cocoachina.com/</a></p>

<p>中国最大的iOS开发网站，这里真的是什么都有哟，亲！</p>

<p>4.其他资源</p>

<p><a href="http://code4app.com/">找代码？看这里-&gt;Code4App</a></p>

<p><a href="http://ui4app.com/">找资源？看这里-&gt;UI4App</a></p>

<h5 id="section-3">(2)书籍类</h5>

<p><a href="http://book.douban.com/subject/4813265/">《Head First iPhone and iPad Development》</a></p>

<p>iOS开发不仅开发的成本很高，入门的门槛也比较高，如果喜欢Head First系列书籍的话不妨先看下这本</p>

<p><a href="http://book.douban.com/subject/19953782/">《iOS 6 Programming Cookbook》</a></p>

<p>这本书介绍的是iOS6编程，虽然现在最新的是iOS7了，但是变化不大，大多数iOS开发书籍是介绍iOS4或者iOS5开发，但是不同版本差异还是比较大，所以推荐看iOS6及以上版本的iOS编程的书籍</p>

<p><a href="http://book.douban.com/subject/24846574/">《iOS开发指南：从零基础到App Store上架》</a></p>

<p>今年出的新书，内容非常详细，作者是关东升，国内知名的iOS开发专家，可以搜到他的新浪微博，他专注于iOS开发，录制过一些iOS开发视频  [这本书我没读过，还没看到过]</p>

<p><a href="http://book.douban.com/subject/25767591/">《疯狂iOS 讲义（上） Objective-C 2.0与iPhone/iPad应用开发基础》</a></p>

<p>李刚老师估计闲不下来，嘿嘿，这是他的新书，貌似要出版了，自然要赞！</p>

<p>其他书籍： [我没怎么读过]</p>

<p><a href="http://book.douban.com/subject_search?search_text=iOS&amp;cat=1001">豆瓣书籍：iOS开发</a></p>

<h4 id="iosiosios-6-programming-cookbookhttphujiaweiyingerdiandiancompost2013-06-04ios6listobjective-ciosios-oo">iOS学习总结：对于iOS开发我还没有完整入门，只是看了英文原汁原味的《iOS 6 Programming Cookbook》，这本书还是很不错的，分不同的开发内容进行讲解，但对于入门还是不够的，我自己读的时候写了些<a href="http://hujiaweiyinger.diandian.com/post/2013-06-04/ios6_list">读书笔记</a>，不嫌难看不妨参考下，嘿嘿。建议先搞懂Objective-C，然后再开始学习iOS开发，不要直接就学习iOS开发，没打好地基是建不了摩天大厦的！另外，开发成本略高，需要苹果机，装黑苹果麻烦，速度还慢，量力而行 O(∩_∩)O</h4>

<hr />

<h3 id="windows-phone">Windows Phone部分</h3>

<p>需要熟悉微软的.NET平台，语言主要是C#，目前Windows Phone资料不算多，图书馆里也就几本书籍，很容易找到那些常见的资源，我没有研究过，在此就不详细提了</p>

<p><a href="http://developer.windowsphone.com/zh-cn">Microsoft Windows Phone Developer 开发者网站</a></p>

<p><a href="http://book.douban.com/subject_search?search_text=Windows+Phone&amp;cat=1001">豆瓣书籍：Windows Phone开发</a></p>

<p>OK！差不多就这些了，有什么问题请<a href="&#109;&#097;&#105;&#108;&#116;&#111;:&#104;&#117;&#106;&#105;&#097;&#119;&#101;&#105;&#048;&#057;&#048;&#056;&#048;&#055;&#064;&#103;&#109;&#097;&#105;&#108;&#046;&#099;&#111;&#109;">通过邮件联系我</a>，谢谢！</p>

<p>[附上两周的Android入门课件和演示应用魔力8号球的源码]</p>

<p><a href="/files/android01.pdf">Android入门课程(上)</a></p>

<p><a href="/files/android02.pdf">Android入门课程(下)</a></p>

<p><a href="/files/magic8.zip">魔力8号球源码</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Ndk and Opencv Development 4]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2014/02/21/android-ndk-and-opencv-development-4/"/>
    <updated>2014-02-21T10:15:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2014/02/21/android-ndk-and-opencv-development-4</id>
    <content type="html"><![CDATA[<h4 id="android-ndkopencv">Android NDK与OpenCV的整合开发环境搭建</h4>

<p>以XFace项目为例，虚拟机的操作系统为64位的Ubuntu 12.04，用户名和密码都是xface  </p>

<p>为便于开始进行XFace人脸识别系统研发，提供了已配置好安卓开发环境的Linux系统（64位的Ubuntu 12.04）虚拟机，在安装好VMware（版本在VMware 8以上）之后，打开Ubuntu 64 xface.vmwarevm目录中Ubuntu 64 xface.vmx，以用户名<code>xface</code>及密码<code>xface</code>登录后，直接打开桌面上的<code>Link to eclipse</code>，便可按本文档第二部分第3步运行XFace工程。如果想要自己搭建开发环境，请从第一部分开始做起。</p>

<h5 id="section">第一部分 搭建环境</h5>
<hr />

<p><strong><em>[注：以下所有下载的sdk都保存在虚拟机的<code>/home/xface/tools</code>目录下，也可以到百度网盘下载，地址是<a href="http://pan.baidu.com/s/1mg2Wdx2">http://pan.baidu.com/s/1mg2Wdx2</a>，不同版本的配置方式可能有些变化，如果不是很清楚版本问题的话，推荐使用虚拟机中使用的版本]</em></strong></p>

<p><img src="/images/201402/tools.png"></p>

<p>1.配置Java环境</p>

<p>①下载<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">Oracle JDK</a>，虚拟机中下载的版本是JDK1.7.0_40</p>

<p>②下载之后解压即可，解压路径为<code>/home/xface/android/jdk1.7.0</code></p>

<p>③打开终端，输入<code>sudo gedit /etc/profile</code>，在文件末尾添加下面内容</p>

<p><code>java
JAVA_HOME=/home/xface/android/jdk1.7.0
export PATH=$JAVA_HOME/bin:$PATH
</code></p>

<p>如下图所示，后面环境配置中添加内容也是如此</p>

<p><img src="/images/201402/etcprofile.png"></p>

<p>④重启虚拟机，打开终端输入<code>java -version</code>进行测试（重启虚拟机也可以等待下面的Android SDK和Android NDK环境都配置好了之后再重启也行）</p>

<p><img src="/images/201402/javaversion.png"></p>

<p>2.配置Android SDK环境</p>

<p>①下载<a href="https://developer.android.com/sdk/index.html">Android Developer Tools</a>，虚拟机中下载的是20130729版本</p>

<p>②下载之后解压即可，解压路径为<code>/home/xface/android/adt-bundle</code></p>

<p>③打开终端，输入<code>sudo gedit /etc/profile</code>，在文件末尾添加下面内容</p>

<p><code>
ANDROID_SDK_ROOT=/home/xface/android/adt-bundle/sdk
export PATH=${PATH}:${ANDROID_SDK_ROOT}/platform-tools:${ANDROID_SDK_ROOT}/tools
</code></p>

<p>④因为Android SDK是32位的，而虚拟机中Ubuntu系统是64位的，所以需要添加ia32-libs库，在终端中执行下面命令（需要耗费漫长的时间等待）</p>

<p><code>
sudo apt-get update
sudo apt-get install ia32-libs
</code></p>

<p>⑤重启虚拟机，打开终端输入<code>adb version</code>进行测试</p>

<p><img src="/images/201402/adbversion.png"></p>

<p>3.配置Android NDK环境</p>

<p>①下载<a href="https://developer.android.com/tools/sdk/ndk/index.html">Android NDK</a>，虚拟机中下载的是r9c版本</p>

<p>②下载之后解压即可，解压路径为<code>/home/xface/android/adt-bundle/ndk</code></p>

<p>③打开终端，输入<code>sudo gedit /etc/profile</code>，在文件末尾添加下面内容</p>

<p><code>
ANDROID_NDK_ROOT=/home/xface/android/adt-bundle/ndk
export PATH=${PATH}:${ANDROID_NDK_ROOT}
</code></p>

<p>④重启虚拟机，打开终端输入<code>ndk-build -v</code>进行测试</p>

<p><img src="/images/201402/ndkversion.png"></p>

<p>4.配置OpenCV环境</p>

<p>①下载<a href="http://sourceforge.net/projects/opencvlibrary/files/opencv-android/">OpenCV for Android</a>，虚拟机中使用的是2.4.4版本</p>

<p>②下载之后解压即可，解压路径为<code>/home/xface/android/opencv_sdk</code></p>

<p>5.配置ADT开发环境</p>

<p>①运行<code>/home/xface/android/adt-bundle/eclipse</code>目录中的eclipse程序，设置默认的工作空间的路径，虚拟机中设置的路径为<code>/home/xface/android/workspace</code></p>

<p>②打开<code>window-&gt;preferences</code>，查看Android SDK和NDK的配置，如果路径有问题则需要修改过来</p>

<p>Android SDK路径的设置</p>

<p><img src="/images/201402/androidsdk.png"></p>

<p>Android NDK路径的设置</p>

<p><img src="/images/201402/androidndk.png"></p>

<p>③打开<code>window-&gt;preferences</code>，找到左侧的<code>C/C++ Build-&gt;Environment</code>添加下面两个环境变量：</p>

<p><code>
NDKROOT=/home/xface/android/adt-bundle/ndk
OPENCVROOT=/home/xface/android/opencv_sdk
</code></p>

<p><img src="/images/201402/environment.png"></p>

<p>④按如下步骤配置<strong>万能的javah工具</strong>的方法（这里javah工具的用途是根据Java类生成C++头文件）</p>

<p>(1)在菜单<code>Run</code>-&gt;<code>External Tools</code>-&gt;<code>External Tools Configurations</code>中新建<code>Program</code>，命名为<code>javah</code></p>

<p>(2)<code>Location</code>设置为<code>/usr/bin/javah</code> [如果javah命令不是在这个位置，可以试试<code>${system_path:javah}</code>]</p>

<p>(3)<code>Working Directory</code>设置为<code>${project_loc}/bin/classes</code> [适用于Android项目开发]</p>

<p>(4)<code>Arguments</code>设置为<code>-jni -verbose -d "${project_loc}${system_property:file.separator}jni" ${java_type_name}</code></p>

<p>(5)OK，以后只要选中要进行”反编译”的Java Class，然后运行这个External Tool就可以了！</p>

<p><img src="/images/201402/javah.png"></p>

<p>⑤为了提高编写代码的速度，打开<code>window-&gt;preferences</code>，找到左侧<code>Java-&gt;Editor-&gt;Content Assist</code>，在<code>Auto activation triggers for Java</code>中添加26个英文字母，这样，在编写Java代码时任何一个字母被按下的话都会出现智能代码提示。</p>

<p><img src="/images/201402/codeassist.png"></p>

<p>⑥为了验证环境没有问题，可以尝试新建一个Android Project并运行于移动设备上，虚拟机中eclipse下的项目xfacetest便是用来测试环境是否配置成功的默认Android应用程序，可以尝试插上手机，选中项目xfacetest点击右键，选择<code>Run As</code> -&gt; <code>Android Application</code>，如果都没问题了，说明开发环境搭建成功了。</p>

<h5 id="xface">第二部分 运行XFace</h5>
<hr />
<p><strong><em>[注：实验使用的XFace项目源代码是稍微精简的版本，可以到百度网盘下载，地址是<a href="http://pan.baidu.com/s/1mg2Wdx2">http://pan.baidu.com/s/1mg2Wdx2</a>，下载之后解压即可，原始的XFace项目托管于Github，地址是<a href="http://github.com/hujiaweibujidao/XFace.git">http://github.com/hujiaweibujidao/XFace.git</a>]</em></strong></p>

<p>XFace是一个小型的人脸识别程序，主要功能就是注册和识别人脸，界面分为3个，首先是主界面，使用者选择要进行的操作，sign up是注册，输入用户名然后保存头像即可；sign in是登录，其实就是人脸识别的过程。</p>

<p><img src="/images/201402/xface.png"></p>

<p>XFace的源码保存在虚拟机中<code>/home/xface/android/xface</code>目录下，包括两个项目，一个是<code>OpenCV Library - 2.4.4</code>，这是XFace所需的OpenCV库项目，另一个是<code>XFace</code>，这个XFace核心的Android应用程序。下面介绍如何将这两个项目导入到Eclipse开发环境中，并在手机上运行。</p>

<p>1.运行Eclipse，选择<code>File-&gt;Import...</code>，在导入窗口中，选择<code>General</code>下面的<code>Existing Projects into Workspace</code>，然后点击<code>Next-&gt;</code>，在之后的窗口中，点击<code>Browser...</code>，选中<code>/home/xface/android/xface/</code>下的<code>OpenCV Library - 2.4.4</code>文件夹，建议勾选<code>Copy projects into workspace</code>（可以防止意外操作导致项目出现问题无法修复时可以删除该项目重新将其导入进来），点击<code>Finish</code>即可，如下图所示：</p>

<p><img src="/images/201402/import.png"></p>

<p>2.按照步骤1中的导入操作导入<code>/home/xface/android/xface/</code>下的<code>XFace</code>项目，导入之后，如果报出问题，可以尝试以下步骤：选中项目<code>XFace</code>，点击右键，选择<code>Properties</code>，在属性配置窗口中，选择左侧的<code>Android</code>项，查看下面的<code>Library</code>的配置，如果有错误，则选中错误的项，点击<code>Remove</code>；如果内容为空则点击<code>Add...</code>，在弹出的窗口中选中步骤1中添加的<code>OpenCV Library - 2.4.4</code>项目即可，效果如下图所示：</p>

<p><img src="/images/201402/library.png"></p>

<p>3.至此，开发环境搭建和项目导入部分都完成了，下面可以进行XFace程序了。首先插入设备（手机），如果是在虚拟机中运行，要确保手机是和虚拟机连接的，而不是和主机连接的（可以通过虚拟机右下角状态栏中<code>USB设备按钮</code>或者菜单<code>虚拟机</code>中的<code>USB和Bluetooth</code>进行设置）；然后，选中<code>XFace</code>项目，点击右键，选择<code>Run As -&gt; Android Application</code>，然后选中插入的手机，点击<code>OK</code>即可。有些情况下可能在列表中没有出现设备，可以尝试以下步骤：首先要确保手机开启了USB调试功能(一般是<code>设置</code>-&gt;<code>开发人员选项</code>-&gt;选中<code>USB调试</code>)；其次可以尝试重新插入手机或者重启Eclipse；若还是不行尝试在终端输入<code>adb kill-server</code>和<code>adb devices</code>命令；若还是不行的话尝试重启电脑。实在是不行的话，将编译好的apk文件（保存在项目的<code>bin</code>目录下）拷贝到手机中直接运行。</p>

<h5 id="xface-1">第三部分 XFace分析</h5>
<hr />

<p>1.项目结构和主要文件功能大致介绍</p>

<p><img src="/images/201402/xfacecode.png"></p>

<p>2.关键部分介绍</p>

<p>(1)<code>jni</code>下的<code>edu_thu_xface_libs_XFaceLibrary.h</code>文件是由Java类<code>XFaceLibrary.java</code>通过javah工具生成的（现在要想重新生成需要将非native方法注释起来），Java类只是定义了三个重要的<code>native</code>方法，实际调用的是实现了头文件<code>edu_thu_xface_libs_XFaceLibrary.h</code>的另一个C++文件<code>xface.cpp</code>。 </p>

<p>三个<code>native</code>方法如下：</p>

<p><code>c++
	public static native long nativeInitFacerec(String datapath, String modelpath, int component, double threshold,
			int facerec);
	public static native int nativeFacerec(long xfacerec, String modelpath, long addr, int width, int height);
	public static native int nativeDestoryFacerec(long xfacerec);
</code></p>

<p>对应得到的头文件中的三个方法（注意：这里方法的名称和参数类型都是严格遵守JNI规范的，不能随便修改）</p>

<p><code>c++
/*
 * Class:     edu_thu_xface_libs_XFaceLibrary
 * Method:    nativeInitFacerec
 * Signature: (Ljava/lang/String;Ljava/lang/String;IDI)J
 */
JNIEXPORT jlong JNICALL Java_edu_thu_xface_libs_XFaceLibrary_nativeInitFacerec
  (JNIEnv *, jclass, jstring, jstring, jint, jdouble, jint);
/*
 * Class:     edu_thu_xface_libs_XFaceLibrary
 * Method:    nativeFacerec
 * Signature: (JLjava/lang/String;JII)I
 */
JNIEXPORT jint JNICALL Java_edu_thu_xface_libs_XFaceLibrary_nativeFacerec
  (JNIEnv *, jclass, jlong, jstring, jlong, jint, jint);
/*
 * Class:     edu_thu_xface_libs_XFaceLibrary
 * Method:    nativeDestoryFacerec
 * Signature: (J)I
 */
JNIEXPORT jint JNICALL Java_edu_thu_xface_libs_XFaceLibrary_nativeDestoryFacerec
  (JNIEnv *, jclass, jlong);
</code></p>

<p>第一个方法是初始化人脸识别模块，参数分别是：datapath是已有的人脸数据保存的文件路径；modelpath是已生成的人脸识别模块保存的文件路径；component是人脸识别算法中使用的一个参数，表示主成分数；threshold也是人脸识别算法中使用的一个参数，表示阈值。后面两个参数目前都是使用默认值，分别是10和0.0。</p>

<p>第二个方法是人脸识别算法，参数分别是：xfacerec人脸识别算法模块对象的内存地址，之前的尝试，目前没有用了，可以忽视；modelpath是创建的人脸识别模块数据的文件保存的路径；addr是当前摄像头得到的一帧图片的灰度图像的内存地址；width和height分别是要进行识别的人脸图片压缩之后的大小，目前是240*360。</p>

<p>第三个方法是销毁人脸识别对象的方法，主要用于释放JNI层中开辟的内存空间。</p>

<p>(2)分析<code>FacerecCameraActivity</code>类</p>

<p>①人脸检测模块</p>

<p>这部分最重要的是<code>private CascadeClassifier mJavaDetector;</code>字段，它的初始化过程在方法<code>onCreate(Bundle savedInstanceState)</code>中，这里使用了重要的<code>lbpcascade_frontalface.yml</code>文件，该文件原本存放在<code>res/raw</code>目录下，初始化过程中将其拷贝到了SD卡中，并使用这个文件创建了<code>CascadeClassifier</code>。代码片段：</p>

<p><code>java
try {
	// File cascadeDir = getDir("cascade", Context.MODE_PRIVATE);
	mCascadeFile = new File(CommonUtil.LBPCASCADE_FILEPATH);
	if (!mCascadeFile.exists()) {// if file not exist, load from raw, otherwise, just use it!
		// load cascade file from application resources
		InputStream is = getResources().openRawResource(R.raw.lbpcascade_frontalface);
		// mCascadeFile = new File(cascadeDir, "lbpcascade_frontalface.xml");
		FileOutputStream os = new FileOutputStream(mCascadeFile);
		byte[] buffer = new byte[4096];
		int bytesRead;
		while ((bytesRead = is.read(buffer)) != -1) {
			os.write(buffer, 0, bytesRead);
		}
		is.close();
		os.close();
	}
	mJavaDetector = new CascadeClassifier(mCascadeFile.getAbsolutePath());
	if (mJavaDetector.empty()) {
		Log.e(TAG, "Failed to load cascade classifier");
		mJavaDetector = null;
	} else
		Log.i(TAG, "Loaded cascade classifier from " + mCascadeFile.getAbsolutePath());
	// mNativeDetector = new DetectionBasedTracker(mCascadeFile.getAbsolutePath(), 0);// hujiawei
	// cascadeDir.delete();//
} catch (IOException e) {
	e.printStackTrace();
	Log.e(TAG, "Failed to load cascade. Exception thrown: " + e);
}
</code></p>

<p>最后在摄像头的回调方法<code>onCameraFrame(CvCameraViewFrame inputFrame)</code>中对摄像头得到的图片帧进行人脸检测，将检测出来的人脸方框直接绘制在图片帧上立刻显示出来（该方法会在每次摄像头有新的一帧）。代码片段如下，其中mRgba是每次得到的图片的RGBA格式，mGray是每次得到的图片的灰度格式</p>

<p><code>java
public Mat onCameraFrame(CvCameraViewFrame inputFrame) {
	// Log.i(TAG, inputFrame.gray().width() + "" + inputFrame.gray().height());
	// landscape 640*480 || portrait [320*240]-&gt; 240*320!
	// when portrait mode, inputframe is 320*240, so pic is rotated!
	mRgba = inputFrame.rgba();
	mGray = inputFrame.gray();
	Core.flip(mRgba.t(), mRgba, 0);//counter-clock wise 90
	Core.flip(mGray.t(), mGray, 0);
	if (mAbsoluteFaceSize == 0) {
		int height = mGray.rows();
		if (Math.round(height * mRelativeFaceSize) &gt; 0) {
			mAbsoluteFaceSize = Math.round(height * mRelativeFaceSize);
		}
		// mNativeDetector.setMinFaceSize(mAbsoluteFaceSize);//
	}
	MatOfRect faces = new MatOfRect();
	if (mJavaDetector != null) {// use only java detector
		mJavaDetector.detectMultiScale(mGray, faces, 1.1, 2, 2, // TODO: objdetect.CV_HAAR_SCALE_IMAGE
				new Size(mAbsoluteFaceSize, mAbsoluteFaceSize), new Size());
	}
	Rect[] facesArray = faces.toArray();
	for (int i = 0; i &lt; facesArray.length; i++) {
		Core.rectangle(mRgba, facesArray[i].tl(), facesArray[i].br(), FACE_RECT_COLOR, 3);
	}
	Core.flip(mRgba.t(), mRgba, 1);//counter-clock wise 90
	Core.flip(mGray.t(), mGray, 1);
	return mRgba;
}
</code></p>

<p>②人脸识别模块</p>

<p>因为人脸识别过程需要耗费一定的时间，如果每次图片帧传入的时候便进行处理，处理完了之后再显示的话会导致界面卡死，所以人脸识别过程是在另开辟的一个线程中执行的，线程代码如下，只要摄像头还在工作，也就是还会传回图像的话，那么这个线程便会取出其灰度图像传入到JNI层进行人脸识别操作，并将结果显示出来，此处消息的传递方式使用的是Android中的Handler机制。</p>

<p><code>java
new Thread(new Runnable() {
	public void run() {
		Log.i(TAG, "bInitFacerec= " + bInitFacerec + " $$ bExitRecognition= " + bExitRecognition
				+ " $$ frameprocessing=" + bFrameProcessing);
		if (!bInitFacerec) {// facerec init?
			long result = XFaceLibrary.initFacerec();// it will take a lot of time!
			Message message = new Message();
			message.arg1 = (int) result;// 1/-1/-2
			message.arg2 = 0;
			handler.sendMessage(message);
			bInitFacerec = true;// no longer init!
		}
		while (!bExitRecognition) {// is recognition exits?
			if (!bFrameProcessing) {// is frame being processing?
				if (null == mGray || mGray.empty()) {//it's hard to say when it is called!
					Log.i(TAG, "gray mat is null");
					// return;// return when no data//can not return
				} else {
					bFrameProcessing = true;
					Log.i(TAG, "runFacerec! addr = " + mGray.getNativeObjAddr());// 2103032
					// Log.i(TAG, "data addr=" + mGray.dataAddr() + " $$ native addr=" +
					// mGray.getNativeObjAddr()
					// + " $$ native object=" + mGray.nativeObj);// $1 not equal $2,but $2=$3
					int result = XFaceLibrary.facerec(mGray);
					Message message = new Message();
					message.arg1 = result;
					message.arg2 = 1;
					handler.sendMessage(message);
					bFrameProcessing = false;
				}
			}
			try {
				Thread.currentThread().sleep(1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
}).start();
</code></p>

<p>3.XFace应用程序在手机SD卡中的相关文件</p>

<p>XFace应用程序的使用过程中会产生一些文件夹和文件，全部存放在SD卡的<code>xface</code>文件夹下。这部分内容可以参看文件<code>CommonUtil.java</code>文件，在包<code>edu.thu.xface.util</code>下。</p>

<p><code>camera</code>文件夹存放摄像头拍照得到的头像；</p>

<p><code>user</code>文件夹存放灰度化和压缩处理之后的头像；</p>

<p><code>demo</code>文件夹存放测试或者示例程序的数据，目前为空；</p>

<p><code>facedata.txt</code>文件存放人脸图片路径和人物的对应关系，文件中<code>图片路径;数字</code>表示该数字编号的人物的头像图片所在的路径；</p>

<p><code>users.properties</code>文件用来保存用户的配置和注册用户的信息，文件中<code>total</code>代表总共注册的人数；后面的<code>数字=用户名</code>表示人物编号与人物名称的对应关系，<code>1=hujiawei</code>表示1号人物代表用户<code>hujiawei</code>，再根据<code>facedata.txt</code>文件中的内容便可以知道<code>hujiawei</code>用户头像图片存储的路径；最后的<code>facerecognizer=?</code>保存当前使用的人脸识别算法，例如<code>facerecognizer=eigenface</code>表示使用的是特征脸算法，XFace虽然内置了OpenCV中的三种人脸识别算法，但是目前只有<code>eigenface</code>和<code>fisherface</code>两种算法可行，第三种<code>lbphface</code>算法暂时不可行。</p>

<p><code>facerec.yml</code>文件是OpenCV中人脸识别算法用来保存创建的识别模块数据的文件；</p>

<p><code>lbpcascade_frontalface.yml</code>文件是OpenCV中进行人脸检测所需要的数据文件；</p>

<h5 id="section-1">第四部分 其他参考内容</h5>
<hr />

<p>其他的参考内容：</p>

<p>①<a href="http://hujiaweibujidao.github.io/blog/2013/12/14/yi-dong-kai-fa-zi-liao-hui-ji/">关于Android开发的书籍和资料</a></p>

<p>文章最后附有两份Android开发入门课程PPT，以及一个Android小程序魔力8号球，百度网盘同样可以下载</p>

<p>②<a href="http://bujingyun23.blog.163.com/blog/static/181310243201210293950303/?suggestedreading&amp;wumii">关于在Ubuntu12.04下搭建android开发环境的教程</a></p>

<p>③<a href="http://hujiaweiyinger.diandian.com/post/2013-10-30/setup_android_ndk_environment_and_solve_some_problems">关于在windows平台搭建android开发环境的教程</a> </p>

<p>不推荐使用Windows进行开发，因为不仅要安装Cygwin，还要进行很多其他的配置，如果实在是不得已，可以尝试参考<a href="http://blog.csdn.net/pwh0996/article/details/8957764">这位博主的环境搭建过程</a></p>

<p>④<a href="http://hujiaweibujidao.github.io/blog/2013/11/18/android-ndk-and-opencv-developement/">关于android ndk和opencv整合开发以及实例项目运行的教程</a></p>

<p>介绍Android NDK和OpenCV整合开发的环境搭建过程和实例项目测试，重点可以参考的是其中的人脸检测和眼镜检测的两个项目，XFace中的人脸检测便来源于此。</p>

<p>⑤<a href="http://hujiaweibujidao.github.io/blog/2013/11/18/android-ndk-and-opencv-development-2/">关于android ndk开发中的各种细节和问题的总结</a></p>

<p>理解javah工具和Android.mk以及Application.mk文件的配置，如果是在Windows平台搭建环境的话，需要查看这部分关于<code>C/C++ Genernal -&gt; Paths and Symbols</code>的配置</p>

<p>⑥<a href="http://bytefish.de/blog/opencv_facerecognizer_documentation/">关于OpenCV中的人脸识别算法 - OpenCV FaceRecognizer documentation</a></p>

<p>该博客作者是OpenCV2.4之后内置的人脸识别模块的原作者，他在他的博客中详细介绍了FaceRecognizer的API以及他使用的人脸识别算法，算法讲解部分可以参考<a href="http://bytefish.de/blog/face_recognition_with_opencv2/">Face Recognition with Python/GNU Octave/Matlab</a>。</p>

]]></content>
  </entry>
  
</feed>
