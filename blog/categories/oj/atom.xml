<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: oj | Hujiawei Bujidao]]></title>
  <link href="http://hujiaweibujidao.github.io/blog/categories/oj/atom.xml" rel="self"/>
  <link href="http://hujiaweibujidao.github.io/"/>
  <updated>2014-11-26T13:26:53+08:00</updated>
  <id>http://hujiaweibujidao.github.io/</id>
  <author>
    <name><![CDATA[hujiawei]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CodeForces Round 278 Div2]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2014/11/22/codeforces-round-278-div2/"/>
    <updated>2014-11-22T11:57:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2014/11/22/codeforces-round-278-div2</id>
    <content type="html"><![CDATA[<p>昨晚又熬夜参加CodeForces了，比赛拖延到1点半才开始，状态果然又是很糟糕，目前解决前面2道题</p>

<h4 id="giga-towerhttpcodeforcescomcontest488problema"><a href="http://codeforces.com/contest/488/problem/A">Giga Tower</a></h4>

<p>这题的大意是给你一个数字，让你求最近的大于这个数字并且含有数字8的数字与这个数字的差值，比如数字9，找到的数字应该是18，差值就是18-9=9。这题我又想多了，心想直接求肯定不行，然后设计了一个看起来不错的得到大于或者小于(用于负数)一个数字的最近的含有数字8的数字，结果写了蛮久了还是有不少bug，没敢提交，后来看到那么多人做出来了，就觉得这题没准直接累加就行，因为毕竟遇到8很容易，一般情况下都能很快得到那个目标数字，结果一试还真是行！</p>

<p>```java
import java.util.Scanner;</p>

<p>public class Test278A2 {</p>

<pre><code>public static void main(String[] args) {
    Scanner cin = new Scanner(System.in);
    int b = 1;
    int a = cin.nextInt();
    String s = String.valueOf(++a);
    while (!s.contains("8")) {
        b++;
        s = String.valueOf(++a);
    }
    System.out.println(b);
}
</code></pre>

<p>}</p>

<p>```</p>

<h4 id="candy-boxeshttpcodeforcescomcontest488problemb"><a href="http://codeforces.com/contest/488/problem/B">Candy Boxes</a></h4>

<p>这题首先告诉我们4个盒子里面的糖果数目满足如下条件</p>

<script type="math/tex; mode=display">x4-x1=\frac{x2+x3}{2}=\frac{x1+x2+x3+x4}{4}, x1 \le x2 \le x3 \le x4</script>

<p>也就是说这四个数字的range，median和average都相同，现在只告诉你其中
n(<script type="math/tex">0 \le n \le 4</script>)个数字，让你求其他的数字，如果有很多的解只需要输出其中的一个即可，如果任何数字都不能满足的话输出NO。</p>

<p>这题其实很简单，首先从上面的连等式中很快能够得到下面的结果</p>

<script type="math/tex; mode=display">x1=\frac{x2+x3}{4}, x4=3*x1</script>

<p>其中x4是x1的3倍是很关键的信息，然后分n分别为0，1，2，3，4这5种情况讨论就行了，难点在于n=2和n=3。</p>

<p>当n=2时，先对这两个已知数排序，然后分别假设它们是(x1, x2)或者(x1, x3)等等所有可能的组合，根据条件求出剩下的两个数字，然后判断这四个数字是否满足条件，如果满足的话那就输出，否则输出NO。</p>

<p>同理，当n=3时，分别假设剩下的那个数字是x1或者x2或者x3或者x4，求出来之后验证即可。</p>

<p>```
import java.util.Arrays;
import java.util.Scanner;</p>

<p>/**
 * hujiawei - 14/11/22.
 */
public class Test278B {</p>

<pre><code>public static void main(String[] args) {
    Scanner cin = new Scanner(System.in);

    int n = cin.nextInt();
    int[] a = new int[n];
    for (int i = 0; i &lt; n; i++) {
        a[i] = cin.nextInt();
    }

    if (n == 0) {
        System.out.println("YES");
        System.out.println("1");
        System.out.println("2");
        System.out.println("2");
        System.out.println("3");
    } else if (n == 1) {
        System.out.println("YES");
        System.out.println(2 * a[0]);
        System.out.println(2 * a[0]);
        System.out.println(3 * a[0]);
    } else if (n == 4) {
        Arrays.sort(a);
        if (check(a[0], a[1], a[2], a[3])) {
            System.out.println("YES");
        } else {
            System.out.println("NO");
        }
    } else if (n == 3) {
        Arrays.sort(a);
        int a1 = a[2] / 3;
        if (check(a1, a[0], a[1], a[2])) {
            System.out.println("YES");
            System.out.println(a1);
            return;
        }
        int a4 = a[0] * 3;
        if (check(a[0], a[1], a[2], a4)) {
            System.out.println("YES");
            System.out.println(a4);
            return;
        }
        int a2 = 4 * a[0] - a[1];
        if (check(a[0], a2, a[1], a[2])) {
            System.out.println("YES");
            System.out.println(a2);
            return;
        }
        int a3 = 4 * a[0] - a[1];
        if (check(a[0], a[1], a3, a[2])) {
            System.out.println("YES");
            System.out.println(a3);
            return;
        }
        System.out.println("NO");
    } else {
        Arrays.sort(a);
        int a1, a2, a3, a4;
        //a1,a4
        a1 = a[0];
        a4 = a[1];
        if (a4 == 3 * a1) {
            a2 = (a1 + a4) / 2;
            a3 = (a1 + a4) / 2;
            if (check(a1, a2, a3, a4)) {
                System.out.println("YES");
                System.out.println(a2);
                System.out.println(a3);
                return;
            }
        }
        //a1,a2
        a1 = a[0];
        a2 = a[1];
        if (4 * a1 &gt; a2) {
            a3 = 4 * a1 - a2;
            a4 = 3 * a1;
            if (check(a1, a2, a3, a4)) {
                System.out.println("YES");
                System.out.println(a3);
                System.out.println(a4);
                return;
            }
        }
        //a1,a3
        a1 = a[0];
        a3 = a[1];
        if (4 * a1 &gt; a3) {
            a2 = 4 * a1 - a3;
            a4 = 3 * a1;
            if (check(a1, a2, a3, a4)) {
                System.out.println("YES");
                System.out.println(a2);
                System.out.println(a4);
                return;
            }
        }
        //a2,a3
        a2 = a[0];
        a3 = a[1];
        if ((a2 + a3) % 4 == 0) {
            a1 = (a2 + a3) / 4;
            a4 = 3 * a1;
            if (check(a1, a2, a3, a4)) {
                System.out.println("YES");
                System.out.println(a1);
                System.out.println(a4);
                return;
            }
        }
        //a2,a4 and a3,a4
        a2 = a[0];
        a4 = a[1];
        if (a4 % 3 == 0) {
            a1 = a4 / 3;
            a3 = 4 * a1 - a2;
            if (check(a1, a2,a3, a4)) {
                System.out.println("YES");
                System.out.println(a1);
                System.out.println(a3);
                return;
            }
        }
        //a3,a4
        a3 = a[0];
        a4 = a[1];
        if (a4 % 3 == 0) {
            a1 = a4 / 3;
            a2 = 4 * a1 - a3;
            if (check(a1, a2,a3, a4)) {
                System.out.println("YES");
                System.out.println(a1);
                System.out.println(a2);
                return;
            }
        }
        //
        System.out.println("NO");
    }
}

private static boolean check(int a1, int a2, int a3, int a4) {
    if (a1 &lt;= a2 &amp;&amp; a2 &lt;= a3 &amp;&amp; a3 &lt;= a4 &amp;&amp; (a4 - a1) == (a2 + a3) / 2 &amp;&amp; (a4 - a1) == (a1 + a2 + a3 + a4) / 4) {
        return true;
    }
    return false;
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CodeForces Round 277.5 Div2]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2014/11/18/codeforces-round-277-dot-5-div2/"/>
    <updated>2014-11-18T10:22:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2014/11/18/codeforces-round-277-dot-5-div2</id>
    <content type="html"><![CDATA[<p>昨晚熬夜刷了CodeForces Round 277.5 Div2，哎，果然很难适应这么晚做题，不在状态，一个小时后才进入状态了，结果比赛完了整个人就睡不着了。。。</p>

<p>这次写解题报告的人很靠谱啊，直接附上关键代码，哈哈哈</p>

<h4 id="a---swapsorthttpcodeforcescomcontest489problema"><a href="http://codeforces.com/contest/489/problem/A">489A - SwapSort</a></h4>

<p>这题很简单，大致就是让你通过不超过n次的数据交换排序一个长度为n的数组，其实用选择排序就行了嘛，我比赛的时候不知怎么搞的，首先想到快排，结果撸了两种快排，终于有一种快排过了pretests，但是后面的system tests就挂了。。。</p>

<p>```java
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Scanner;</p>

<p>//http://codeforces.com/contest/489/problem/A</p>

<p>//选择排序，最多只需要n次交换</p>

<p>public class SwapSort2775A {</p>

<pre><code>private static ArrayList&lt;ASwap2&gt; swaps;

public static void main(String[] args) {
    Scanner cin = new Scanner(System.in);
    int n = cin.nextInt();
    int[] a = new int[n];
    for (int i = 0; i &lt; n; i++) {
        a[i] = cin.nextInt();
    }
    swaps = new ArrayList&lt;ASwap2&gt;();
    int t;
    for (int i = 0; i &lt; n; i++) {
        t = i;
        for (int k = i; k &lt; n; k++) {
            if (a[k] &lt; a[t]) t = k;//
        }
        if (t != i) {
            swaps.add(new ASwap2(t, i));
            int s = a[i];
            a[i] = a[t];
            a[t] = s;
        }
    }
    System.out.println(swaps.size());
    for (ASwap2 swap : swaps) {
        System.out.println(swap.x + " " + swap.y);
    }
}

static class ASwap2 {//

    int x, y;

    ASwap2(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
</code></pre>

<p>}
```</p>

<h4 id="b---bersu-ballhttpcodeforcescomcontest489problemb"><a href="http://codeforces.com/contest/489/problem/B">489B - BerSU Ball</a></h4>

<p>这题大意是n个男孩m个女孩的舞蹈技能不同，匹配时要满足他们的技能差值不超过1，求最大匹配。我一看完了慌了，这么快就要二分图匹配了？可是当我快速复习二分图匹配(大神请尽情鄙视新手吧…)时发现，尼玛这题贪心就行了啊，结果一分钟一撸就过了！核心代码就像是在做合并排序的合并操作，用两个指针分别指向两个数组的当前元素下标，如果它们能满足配对就配对，然后两个指针都向后移动，不能的话数据较小的对应的指针向后移动就行了。</p>

<p>```
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Scanner;</p>

<p>//http://codeforces.com/contest/489/problem/B</p>

<p>//贪心</p>

<p>public class BerSUBall2775B {</p>

<pre><code>public static void main(String[] args) {
    Scanner cin = new Scanner(System.in);
    int n = cin.nextInt();
    int[] a = new int[n];
    for (int i = 0; i &lt; n; i++) {
        a[i] = cin.nextInt();
    }
    int m = cin.nextInt();
    int[] b = new int[m];
    for (int i = 0; i &lt; m; i++) {
        b[i] = cin.nextInt();
    }
    Arrays.sort(a);
    Arrays.sort(b);
    int count = 0;
    int i = 0, j = 0;
    while (i &lt; n &amp;&amp; j &lt; m) {
        if (Math.abs(a[i] - b[j]) &lt;= 1) {
            i++;
            j++;
            count++;
        } else {
            if (a[i] &lt; b[j]) {
                i++;
            } else {
                j++;
            }
        }
    }
    System.out.println(count);
}
</code></pre>

<p>}
```</p>

<h4 id="c---given-length-and-sum-of-digitshttpcodeforcescomcontest489problemc"><a href="http://codeforces.com/contest/489/problem/C">489C - Given Length and Sum of Digits…</a></h4>

<p>这题大意是求由<code>m</code>位数字组成的且各位数字之和为<code>s</code>的最大数和最小数，最大数我们可以通过贪心的方式来得到，也就是从高位往低位开始设置每位的值，当前位总是取它能取的最大的那个数字，如果最终得到的最大数的最后一个数字不是<code>1</code>的话，那么翻转最大数就是最小数了，否则将最小数视为第一位数字是<code>1</code>，后面是满足由<code>m-1</code>位数字组成的且各位数字之和为<code>s-1</code>的最大数的翻转数，注意<code>m=1</code>的情况(被这个坑坑了好几次…)</p>

<p>```
import java.util.Scanner;</p>

<p>//http://codeforces.com/contest/489/problem/C</p>

<p>//贪心</p>

<p>public class GivenLengthandSumofDigits2775C {</p>

<pre><code>public static void main(String[] args) {
    Scanner cin = new Scanner(System.in);

    int m = cin.nextInt();
    int s = cin.nextInt();

    if ((9 * m &lt; s) || (s &lt; 1 &amp;&amp; m &gt; 1)) {
        System.out.println("-1 -1");
        return;
    }

    String max = findMax(m, s);
    String min = "";

    //求最小值
    if (max.charAt(max.length() - 1) != '0') {
        min = new StringBuilder(max).reverse().toString();
        System.out.println(min + " " + max);
        return;
    }

    //特殊情况
    if (m == 1) {
        min = "" + s;
    } else {
        min = findMax(m - 1, s - 1);
        min = "1" + new StringBuilder(min).reverse().toString();
    }

    System.out.println(min + " " + max);
}

//求最大值
static String findMax(int m, int s) {
    int k = 1;//当前第几位
    int r = s;//剩余的总和

    String max = "";
    while (k &lt;= m) {
        if (r &gt;= 9) {
            max = max + "9";
            r = r - 9;
        } else {
            max = max + r;
            r = 0;
        }
        k++;
    }
    return max;
}
</code></pre>

<p>}
```</p>

<h4 id="d---unbearable-controversy-of-beinghttpcodeforcescomcontest489problemd"><a href="http://codeforces.com/contest/489/problem/D">489D - Unbearable Controversy of Being</a></h4>

<p>这题内容比较长，大致就是说给你一些节点和某些节点之间的边的信息，求出该图中有多少个如题目中图示给出的那样的菱形，即节点a可以通过节点b也可以通过节点d到达节点c。这道题目解题报告给出的解法就是枚举，遍历任何两个节点a和c，求出它们中间的候选节点b和d，简单的方法是考虑与a相邻的节点是否也与节点c相邻，如果是的话那么该节点算是一个候选节点。最后由于节点a和节点c之间的任何两个候选节点的组合都能得到所需的菱形，那么就是C(r,2)，所有的这些组合相加就是最终的解。</p>

<p>比较郁闷的是本题如果用Java来完成的话貌似一定需要精简代码，最好不要使用ArrayList等，而是使用原始的数组，以一定的空间来换时间，否则很容易超时。</p>

<p>```
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Scanner;</p>

<p>//http://codeforces.com/contest/489/problem/D</p>

<p>//组合题，空间换时间</p>

<p>public class UnbearableControversyofBeing2775D {</p>

<pre><code>public static void main(String[] args) {
    Scanner cin = new Scanner(System.in);

    int n = cin.nextInt();
    int[] s = new int[n];//s[i]=j表示节点i有j个邻居
    int[][] v = new int[n][n];//v[i][j]=1 表示节点i和节点j相连
    int[][] t = new int[n][n];//t[i][j]=k表示节点i第j个邻居是k

    int m = cin.nextInt();
    int a, b;
    for (int i = 0; i &lt; m; i++) {
        a = cin.nextInt();
        b = cin.nextInt();
        v[a - 1][b - 1] = 1;
        t[a - 1][s[a - 1]] = b - 1;
        s[a - 1]++;
    }

    //
    int count = 0;
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (i != j) {//not the same node
                int r = 0, n1;
                for (int k = 0; k &lt; s[i]; k++) {
                    n1 = t[i][k];
                    if (n1 != i &amp;&amp; n1 != j &amp;&amp; v[n1][j] == 1) {//nodes.get(n1).contains(j)
                        r++;
                    }
                }
                count += r * (r - 1) / 2;//combination
            }
        }
    }
    System.out.println(count);
}
</code></pre>

<p>}
```</p>

<p>后面的等做了再附上。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ACdream Java Contest]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2014/11/14/acdream-java-contest/"/>
    <updated>2014-11-14T15:34:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2014/11/14/acdream-java-contest</id>
    <content type="html"><![CDATA[<p>前天参加了ACdream训练赛系列のJava专场，成绩很烂，感谢<a href="http://mathlover.info/archives/acdream_java#comment-4460">出题人的解题报告</a></p>

<p><a href="http://acdream.info/problem?pid=1669">A题:数一的偶像</a></p>

<p>这道题目出得很好，我也是输出前面100个数字的结果看到一点规律，可惜不是最终的规律。我发现的是首先出现3个1，然后5个0，然后7个1，然后9个0，一直往下延续，仔细想，个数刚好是相邻的完全平方数的差值，3=4-1，5=9-4，7=16-9等等，如果写下来更加容易看出规律：</p>

<p>3(1):  1  2  3  <br />
5(0):  4  5  6  7  8  <br />
7(1):  9 10 11 12 13 14 15  <br />
9(0): 16 17 18 19 20 21 22 23 24  <br />
…</p>

<p>仔细观察每行的第一个数字就知道它们正是完全平方数，但是为什么这么凑巧呢？其实，函数 <script type="math/tex">y=\frac{n}{x}</script> 是一个关于直线 <script type="math/tex">y=x</script> 对称的函数，那么除了在直线 <script type="math/tex">y=x</script> 上的点之外，其他的点数之和一定是偶数，所以只要看该函数与直线 <script type="math/tex">y=x</script> 的交点即可，实际上问题就变成n前面有几个完全平方数，即求n的平方根(然后对2取模即可)。</p>

<p>但是题目给出的n可能很大很大，对它求平方根又成为了一个问题，这里可以使用经典的二分法来逼近。</p>

<p>```java
import java.math.BigInteger;
import java.util.Scanner;</p>

<p>//http://acdream.info/problem?pid=1669</p>

<p>public class Test1669 {</p>

<pre><code>public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);
    BigInteger n;
    while (scanner.hasNext()) {
        n = scanner.nextBigInteger();
        solve(n);
    }
}

private static void solve(BigInteger n) {
    BigInteger l = BigInteger.ONE;
    BigInteger r = n;
    BigInteger mid;
    while (l.compareTo(r) &lt;= 0) {
        mid = l.add(r).shiftRight(1);
        if (mid.multiply(mid).add(mid).add(mid).compareTo(n) &lt; 0) {
            l = mid.add(BigInteger.ONE);
        } else {
            r = mid.subtract(BigInteger.ONE);
        }
    }
    System.out.println(l.remainder(BigInteger.valueOf(2)));
}
</code></pre>

<p>}
```</p>

<p><a href="http://acdream.info/problem?pid=1670">B题:数一的偶像2</a></p>

<p>这题纯数学题，表示不知道这个公式的跪了好久好久。。。</p>

<p>欧拉函数 <script type="math/tex">phi(x) = x \prod_{p}{(1-1/p)}</script> ，其中p是x的质因子</p>

<p>问题就变成了求 <script type="math/tex">\prod_{p}{(1-1/p)}</script> 的在不超过n的情况下最小值，而质因子都是大于等于2的，所以这个值随着质因子越来越多值反而越来越小，所以只要保证其值不超过n，尽可能地添加质因子就能得到最小值。以下代码包含一个素数筛选过程，和标程略有不同。</p>

<p>```
import java.math.BigInteger;
import java.util.Scanner;</p>

<p>//http://acdream.info/problem?pid=1670</p>

<p>public class Test1670 {
    public static void main(String arg[]) {
        int p[] = new int[10000];//存储素数 2 3 5 7 11 13 17 19 23 29 …
        boolean isnp[] = new boolean[10001];//标记是否为素数
        int pn = 0;//标记是第pn个素数，结合p[]可以得到对应的素数，2是第0个
        isnp[0] = isnp[1] = true;//isnp[i]=true表示i不是素数
        for (int i = 2; i &lt;= 10000; ++i) {
            if (!isnp[i]) {//默认都是false的
                p[pn++] = i;//添加一个素数
            }
            //for (int j = 0; j &lt; pn &amp;&amp; i * p[j] &lt;= 10000; ++j) {
            //    isnp[i * p[j]] = true;
            //    if (i % p[j] == 0)
            //        break;
            //}
            for (int j = 0; i * j &lt;= 10000; ++j) {
                isnp[i * j] = true;//给定范围的数字中素数的整数倍一定不是素数
            }
        }</p>

<pre><code>    Scanner cin = new Scanner(System.in);
    while (cin.hasNext()) {
        int i = 0;
        BigInteger n = cin.nextBigInteger(), now = BigInteger.ONE;
        while (now.multiply(BigInteger.valueOf(p[i])).compareTo(n) &lt;= 0) {
            now = now.multiply(BigInteger.valueOf(p[i]));
            i++;
        }
        System.out.println(now.toString());
    }
} } ```
</code></pre>

<p><a href="http://acdream.info/problem?pid=1668">C题:数一与ACM的虐恋</a></p>

<p>我表示做这道题目很虐好么，要不要这么虐我们，就当是学习了下BigDecimal怎么用的吧，精度精度。。。</p>

<p>这题其实很简单，DP，但是状态转移是带着概率的，标程的坐标系是自底向上从左往右来的，初始时dp[n][1]=0，dp[n][i]=i-1，对于整个上三角的斜边上的位置只有两种走法，所以有</p>

<p>dp[i][1]=(a+c<em>0.5)</em>(dp[i+1][1]+1))+(b+c<em>0.5)</em>(dp[i+1][2]+1)</p>

<p>其他位置上有三种走法，有</p>

<p>dp[i][j]=a<em>(dp[i+1][j]+1)+b</em>(dp[i+1][j+1]+1)+c*(dp[i][j-1]+1)</p>

<p>以下是标程</p>

<p>```
import java.math.BigDecimal;
import java.util.Scanner;</p>

<p>//http://acdream.info/problem?pid=1668</p>

<p>public class Test1668 {
    public static void main(String arg[]) {
        int n;
        BigDecimal p[] = new BigDecimal[5];
        Scanner cin = new Scanner(System.in);
        while (cin.hasNext()) {
            n = cin.nextInt();
            for (int i = 0; i &lt; 3; ++i) {
                int a = cin.nextInt();
                int c = cin.nextInt();
                p[i] = BigDecimal.valueOf(a).divide(BigDecimal.valueOf(c), 100, BigDecimal.ROUND_HALF_EVEN);
            }
            //a=p[0], b=p[1], c=p[2], a+c/2=p[3], b+c/2=p[4]
            p[3] = p[0].add(p[2].divide(BigDecimal.valueOf(2), 100, BigDecimal.ROUND_HALF_EVEN));
            p[4] = p[1].add(p[2].divide(BigDecimal.valueOf(2), 100, BigDecimal.ROUND_HALF_EVEN));
            //
            BigDecimal[][] dp = new BigDecimal[n + 2][n + 2];
            for (int i = 0; i &lt;= n + 1; ++i)
                for (int j = 0; j &lt;= n + 1; ++j)
                    dp[i][j] = BigDecimal.valueOf(0.0).setScale(100);
            //dp[n][1] = BigDecimal.valueOf(0.0).setScale(100);//多余
            for (int i = 2; i &lt;= n; ++i)
                dp[n][i] = dp[n][i].add(dp[n][i - 1].add(BigDecimal.ONE));//no += here!
            //从上往下，从左往右依次递推
            for (int i = n - 1; i &gt;= 1; –i) {
                dp[i][1] = dp[i][1].add(p[3].multiply(dp[i + 1][1].add(BigDecimal.ONE))).add(p[4].multiply(dp[i + 1][2].add(BigDecimal.ONE)));
                for (int j = 2; j &lt;= n; ++j)
                    dp[i][j] = dp[i][j].add(p[0].multiply(dp[i + 1][j].add(BigDecimal.ONE)).add(p[1].multiply(dp[i + 1][j + 1].add(BigDecimal.ONE))).add(p[2].multiply(dp[i][j - 1].add(BigDecimal.ONE))));
            }
            System.out.println(dp[1][1].setScale(50, BigDecimal.ROUND_HALF_EVEN).toString());
        }
    }
}
```</p>

<p><a href="http://acdream.info/problem?pid=1667">D题:调皮的数一</a></p>

<p>这题其实很简单，DP，不过我找到的又不是最好的递推式，不过易于理解，好在卡得不紧张可以打表通过。[标程600ms多一点，我的1000ms多一点]</p>

<p>设f[k][t]表示第k步在t跑道，f[0][1]=1，f[1][1]=1，且有</p>

<p>f[k][t]=f[k-1][t-1]+f[k-1][t]+f[k-1][t+1]</p>

<p>根据递推式能够求得最终解f[n][1]。</p>

<p>```
import java.math.BigInteger;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;</p>

<p>//http://acdream.info/problem?pid=1667</p>

<p>public class Test1667 {</p>

<pre><code>private static BigInteger[][] f;

public static void main(String[] args) {
    cal();
    Scanner scanner = new Scanner(System.in);
    int n;
    while (scanner.hasNext()) {
        n = scanner.nextInt();
        System.out.println(f[n][1]);
    }
}

private static void cal() {
    int len = 1001;
    f = new BigInteger[len][len + 1];
    for (int i = 0; i &lt; len; i++) {
        for (int j = 0; j &lt; len + 1; j++) {
            f[i][j] = BigInteger.ZERO;
        }
    }
    f[0][1] = BigInteger.ONE;
    for (int i = 1; i &lt; len; i++) {
        for (int j = 1; j &lt;= i + 1; j++) {
            f[i][j] = f[i - 1][j - 1].add(f[i - 1][j]).add(j + 1 &gt; len ? BigInteger.ZERO : f[i - 1][j + 1]);
        }
    }
}
</code></pre>

<p>}
```</p>

<p>但是此题还有更优的递推式，我打表算法是 <script type="math/tex">O(n^2)</script>的，但是其实可以根据上面的递推式得到一个新的 <script type="math/tex">O(n)</script> 的递推式，具体式子见<a href="http://mathlover.info/archives/acdream_java#comment-4460">出题者的解题报告</a>，我目前还未理解，等我理解了再更新。</p>

<p>标程如下：</p>

<p>```
import java.math.BigInteger;
import java.util.<em>;
import java.io.</em>;</p>

<p>public class Main
{</p>

<pre><code>public static void main(String arg[]) throws IOException
{
    Scanner in = new Scanner(System.in);
    BigInteger ans[]=new BigInteger[1005];
    ans[0]=BigInteger.ONE;
    ans[1]=BigInteger.ONE;
    for(int i=2;i&lt;=1000;++i)
        ans[i]=ans[i-1].multiply(BigInteger.valueOf(2*i+1)).add(ans[i-2].multiply(BigInteger.valueOf(3*i-3))).divide(BigInteger.valueOf(i+2));
    while(in.hasNext())
    {
        int n=in.nextInt();
        byte[] buff = (String.valueOf(ans[n])+"\n").getBytes();
        System.out.write(buff);
    }
} } ```
</code></pre>

<p>E题算了，我觉得此题很无聊，=o=</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BestCoder Round 17]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2014/11/09/bestcoder-round-17/"/>
    <updated>2014-11-09T20:16:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2014/11/09/bestcoder-round-17</id>
    <content type="html"><![CDATA[<p>最近终于确定了接下来要做什么，为了明年能够顺利拿到offer，我要从平时开始多做题了，多思考，不再接什么项目了。搜索了一番发现了一些好的比赛，比如CodeForces和BestCoder，哈哈哈，说练就练！</p>

<p>下面是昨天注册参加的BestCoder Round 17，总共四道题，只搞定了两道，后面那道还被别人hack掉了，当时想过可能会超过int的表示范围，但是时间不多就没多想了，菜鸟阶段暂时只能如此了。</p>

<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5100">Chessboard</a></p>

<p>第一题是说用大小为 k<em>1 的方砖来填充 n</em>n 的棋盘，问棋盘中最多能够有多少个方格能够被覆盖。</p>

<p><a href="http://www.matrix67.com/blog/archives/5900">Matrix67</a> 在他的博客中具体地介绍过这个问题的解法，其实就是两种情况，一个是可以直观地尽可能多地覆盖，另一个是以风车形式覆盖，这题代码很好写，但是思路不好想。</p>

<p>BestCoder题解：</p>

<p>首先，若n&lt;k，则棋盘连一个1×k的矩形都放不下，输出0。      <br />
我们只需要考虑n≥k的情况。将棋盘类似于黑白染色，按(i+j)模k划分等价类，给每个格子标一个号。标号之后，会注意到每条从左下到右上的斜线数字都是相同的，那么对于s×s的格子，其内部数字有且恰好有2s−1种，所以当 <script type="math/tex">% &lt;![CDATA[
s<=\frac{k}{2} %]]&gt;</script> 的时候，内部数字有 <script type="math/tex">% &lt;![CDATA[
floor(\frac{k}{2})*2−1<k %]]&gt;</script> 种，所以不能有更佳的方案。从而证明最优的方案一定是仅剩下一个s×s的正方形区域没有被覆盖到，其中 <script type="math/tex">% &lt;![CDATA[
s<=\frac{k}{2} %]]&gt;</script>。     <br />
而令l=n mod k之后，根据l大小的不同，可以构造出中心为l×l或(k−l)×(k−l)的风车形图案，又通过上面证明这个l（或k−l）就是之前的s，所以是最优的。所以令l=n mod k，如果 <script type="math/tex">% &lt;![CDATA[
l<=\frac{k}{2} %]]&gt;</script>，最多可覆盖的格子数即为 <script type="math/tex">n^2−l^2</script>，否则为 <script type="math/tex">n^2−(k−l)^2</script>，显然这样的方案是可以构造出来的（风车形）。</p>

<p>```java</p>

<p>import java.util.Scanner;</p>

<p>//http://acm.hdu.edu.cn/showproblem.php?pid=5100</p>

<p>//思路，根据n%k和k/2的大小关系来判断如何覆盖</p>

<p>public class Cheeseboard17A {</p>

<pre><code>public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);
    int t = scanner.nextInt();
    while (t-- &gt; 0) {
        int n = scanner.nextInt();
        int k = scanner.nextInt();
        if (k &gt; n) {
            System.out.println("0");
            continue;
        }
        int m = n % k;
        if (m &gt; k / 2) {
            System.out.println(n * n - (k - m) * (k - m));
        } else {
            System.out.println(n * n - m * m);
        }
    }
}
</code></pre>

<p>}</p>

<p>```</p>

<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5101">Select</a></p>

<p>题目大意就是给定一些集合，选择两个来自不同集合的数，加和大于k，问有多少种选择方案。</p>

<p>思路：答案=从所有数中选择的两个加和大于k的数的方案数-在同一个集合中选择的两个加和大于k的数的方案数，而对于同一个集合中选择的两个加和大于k的方案数是可以直接排序然后利用单调性快速统计出来的。</p>

<p>实现：将满足条件的所有组合减去每个班级中满足条件的所有组合，求解时可以将所有学生视为一个新的班，先对所有班级的学生IQ值排序，某个班满足条件的组合数目类似二分策略的插入排序，就是要找到数组的某个子序列中大于等于某个数的所有数字的个数。</p>

<p>```
import java.util.Arrays;
import java.util.Scanner;</p>

<p>//http://acm.hdu.edu.cn/showproblem.php?pid=5101</p>

<p>public class Select17B2 {</p>

<pre><code>public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);
    int t = scanner.nextInt();
    while (t-- &gt; 0) {
        int n = scanner.nextInt();
        int s = scanner.nextInt();
        int[][] vs = new int[n][];
        int allm = 0;
        for (int i = 0; i &lt; n; i++) {//获取数据
            int m = scanner.nextInt();
            allm += m;
            vs[i] = new int[m];
            for (int j = 0; j &lt; m; j++) {
                vs[i][j] = scanner.nextInt();
            }
        }
        //排序每个班级
        for (int i = 0; i &lt; n; i++) {
            Arrays.sort(vs[i]);
        }
        //排序所有学生
        int offset = 0;
        int[] all = new int[allm];
        for (int i = 0; i &lt; n; i++) {
            System.arraycopy(vs[i], 0, all, offset, vs[i].length);
            offset += vs[i].length;
        }
        Arrays.sort(all);

        long sum = getCount(all, s);
        //System.out.println(sum);
        for (int i = 0; i &lt; n; i++) {
            sum -= getCount(vs[i], s);
        }
        System.out.println(sum);
    }
}

//得到一个数组中满足两个元素之和大于s的组合数
private static long getCount(int[] all, int s) {
    long res = 0;
    for (int i = 0, l = all.length; i &lt; l; i++) {
        if (all[i] &gt;= s) {//这个数比s+1更大，那么后面的数都可以和它组合
            res += l - i - 1;//
        } else {//否则的话找到从后面哪个数字开始可以和它进行组合
            int r = s + 1 - all[i];
            res += bs(all, r, i + 1, l-1);
        }
    }
    return res;
}

//得到一个数组从from到end之间满足大于等于r的数字的个数 [二分查找]
private static int bs(int[] vs, int r, int from, int end) {
    int len = end - from + 1;//
    if (len &lt;= 0) return 0;
    int left = from, right = end, mid = 0;
    while (left &lt;= right) {
        mid = (left + right) / 2;
        if (r &lt;= vs[mid]) {
            right = mid - 1;
        } else if (r &gt; vs[mid]) {
            left = mid + 1;
        }
    }
    return end - left + 1;
}
</code></pre>

<p>}</p>

<p>```</p>

<p>后面的等我写好了再附上，嘿嘿嘿。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google APAC 2015 University Graduates Test Round D]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2014/11/09/google-apac-2015-university-graduates-test-round-d/"/>
    <updated>2014-11-09T19:09:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2014/11/09/google-apac-2015-university-graduates-test-round-d</id>
    <content type="html"><![CDATA[<p>前段时间才知道的Google APAC比赛，于是乎注册了今天下午的比赛，Round D，总共四道题，只过了两道，完了之后现在过了三道。这三道都不难只是觉得很奇怪，不熟悉这种比赛模式，它是让你下载输入文件，然后你在给定时间内提交输出文件和源程序即可，对于每道题目都有一个小测试集和大测试集。我以为一般大测试集肯定不好过的，但是纳闷的是其实也很好过，所以本来第二题暴力很简单就能过，我以为要优化，写了半天还是错了，于是在比赛前暴力了一下，结果竟然过了，哎，请理解俺这个菜鸟。</p>

<p>废话不多说了，下面是前三题的解题报告 </p>

<p>[我的代码总是冗长冗长的，可读性高，但是花的时间总是比别人长，所以我真心不适合比赛，汗⊙﹏⊙]</p>

<h3 id="problem-a-cube-ivhttpscodegooglecomcodejamcontest6214486dashboardsp0"><a href="https://code.google.com/codejam/contest/6214486/dashboard#s=p0">Problem A. Cube IV</a></h3>

<p>问题A是说在S*S个方格中，每个方格代表一个房间，房间有一个房间编号，从1到S的平方，每个里面有一个人，这个人可以从一个房间A移动到另一个房间B，但是必须满足房间B的编号比房间A的编号大1才行，问哪个房间的人能够移动的距离最远，最远的距离又是多少？如果两个人能够移动的距离相同，输出房间号小的那个人。</p>

<p>思路：自始至终维护结果r和d，从房间号最大的那个房间开始DFS，遇到房间号小1的房间就进入，一直下去直到不能移动了，修改r和d的值，然后从比上次停下来的房间小1的房间开始继续DFS，如果他移动的距离更多的话，那么就修改d和r即可，一直下去就能得到最终解。</p>

<p>```java
import java.io.BufferedOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.util.Scanner;</p>

<p>//https://code.google.com/codejam/contest/6214486/dashboard#s=p0</p>

<p>public class ProblemA {</p>

<pre><code>private static int s;
private static int[][] p;

public static void main(String[] args) throws Exception {
    PrintStream out = new PrintStream(new BufferedOutputStream(new FileOutputStream("data/out.txt")));
    System.setOut(out);
    System.setErr(out);
    Scanner scanner = new Scanner(new FileInputStream("data/in.txt"));
    int t = scanner.nextInt();
    int c = 1;
    while (t-- &gt; 0) {
        s = scanner.nextInt();
        p = new int[s][s];
        for (int i = 0; i &lt; s; i++) {
            for (int j = 0; j &lt; s; j++) {
                p[i][j] = scanner.nextInt();
            }
        }
        System.out.print("Case #" + c + ": ");
        solve();
        c++;
    }
    out.flush();
    out.close();
}

private static void solve() {
    int r = 0, d = 1, max = s * s;
    while (max &gt; 0 &amp;&amp; max &gt;= d) {
        Point maxp = findPoint(max);
        Result result = new Result(1, 1);
        dfs(maxp, result);
        if (result.d &gt;= d) {
            r = result.r;
            d = result.d;
        }
        max = max - result.d;//
    }
    System.out.println(r + " " + d);
}

private static void dfs(Point current, Result result) {
    //left
    Point left = current.left();
    if (left != null &amp;&amp; p[left.x][left.y] == p[current.x][current.y] - 1) {
        result.r = p[left.x][left.y];
        result.d++;
        dfs(left, result);
        return;
    }
    //right
    Point right = current.right();
    if (right != null &amp;&amp; p[right.x][right.y] == p[current.x][current.y] - 1) {
        result.r = p[right.x][right.y];
        result.d++;
        dfs(right, result);
        return;
    }
    //up
    Point up = current.up();
    if (up != null &amp;&amp; p[up.x][up.y] == p[current.x][current.y] - 1) {
        result.r = p[up.x][up.y];
        result.d++;
        dfs(up, result);
        return;
    }
    //down
    Point down = current.down();
    if (down != null &amp;&amp; p[down.x][down.y] == p[current.x][current.y] - 1) {
        result.r = p[down.x][down.y];
        result.d++;
        dfs(down, result);
        return;
    }
}

private static Point findPoint(int max) {
    for (int i = 0; i &lt; s; i++) {
        for (int j = 0; j &lt; s; j++) {
            if (p[i][j] == max) {
                return new Point(s, i, j);
            }
        }
    }
    return null;
}
</code></pre>

<p>}</p>

<p>class Point {</p>

<pre><code>int s;
int x;
int y;

Point(int s, int x, int y) {
    this.s = s;
    this.x = x;
    this.y = y;
}

Point up() {
    if (x - 1 &gt;= 0) return new Point(this.s, this.x - 1, this.y);
    return null;
}

Point down() {
    if (x + 1 &lt; s) return new Point(this.s, this.x + 1, this.y);
    return null;
}

Point left() {
    if (y - 1 &gt;= 0) return new Point(this.s, this.x, this.y - 1);
    return null;
}

Point right() {
    if (y + 1 &lt; s) return new Point(this.s, this.x, this.y + 1);
    return null;
} }
</code></pre>

<p>class Result {</p>

<pre><code>int r;
int d;

Result(int r, int d) {
    this.r = r;
    this.d = d;
} }
</code></pre>

<p>```</p>

<h3 id="problem-b-gbus-counthttpscodegooglecomcodejamcontest6214486dashboardsp1"><a href="https://code.google.com/codejam/contest/6214486/dashboard#s=p1">Problem B. GBus count</a></h3>

<p>问题B是说在一些城市之间有一些公交车，给你这些车的起点和终点的数据，假设某辆公交车是从1到10，那么城市1、城市2、城市3等一直到城市10都被经过了，现在要求的是有多少辆车经过了某个城市？</p>

<p>思路：这简直不能叫做思路！纯暴力就行了！遍历所有公交车的线路，统计判断该城市是否在这个线路上即可。这样就已经可以过了！比赛时我想了写优化，大致思路是假设城市编号为c，公交车的线路为 <script type="math/tex">a_{i}</script> 和 <script type="math/tex">b_{i}</script>，首先对所有公交线路按照 <script type="math/tex">a_{i}</script> 排序，保留那些 <script type="math/tex">% &lt;![CDATA[
a_{i}<=c %]]&gt;</script> 的线路，然后对这些线路按照 <script type="math/tex">b_{i}</script> 排序，保留那些 <script type="math/tex">{b_{i}>=c}</script> 的线路，最后保留下来的线路的个数就是最终的解。[但是我的代码有问题，即下面的<code>solve</code>方法，提交了几次都报错]</p>

<p>```
import java.io.BufferedOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.util.*;</p>

<p>//https://code.google.com/codejam/contest/6214486/dashboard#s=p1</p>

<p>public class ProblemB {</p>

<pre><code>private static int n, p;
private static ArrayList&lt;Bus&gt; buses;
private static ArrayList&lt;Integer&gt; cities;

public static void main(String[] args) throws Exception {
    PrintStream out = new PrintStream(new BufferedOutputStream(new FileOutputStream("data/out.txt")));
    System.setOut(out);
    System.setErr(out);
    Scanner scanner = new Scanner(new FileInputStream("data/in.txt"));

    int t = scanner.nextInt();
    int c = 1;
    while (t-- &gt; 0) {
        buses = new ArrayList&lt;Bus&gt;();
        cities = new ArrayList&lt;Integer&gt;();
        n = scanner.nextInt();
        for (int i = 0; i &lt; n; i++) {
            buses.add(new Bus(scanner.nextInt(), scanner.nextInt()));
        }
        p = scanner.nextInt();
        for (int i = 0; i &lt; p; i++) {
            cities.add(scanner.nextInt());
        }
        System.out.print("Case #" + c + ": ");
        solve2();
        System.out.println();
        c++;
    }

    out.flush();
    out.close();
}

//暴力解决
private static void solve2() {
    int key, sum;
    for (int i = 0; i &lt; p; i++) {
        key = cities.get(i);
        sum = 0;
        for (Bus bus : buses) {
            if (key &gt;= bus.x &amp;&amp; key &lt;= bus.y) {
                sum++;
            }
        }
        System.out.print(sum + " ");
    }
}

//非暴力解决，但是仍然存在问题
private static void solve() {
    Comparator&lt;Bus&gt; cf = new Comparator&lt;Bus&gt;() {
        @Override
        public int compare(Bus o1, Bus o2) {
            if (o1.x &gt; o2.x) {
                return 1;
            } else if (o1.x &lt; o2.x) {
                return -1;
            }
            return 0;
        }
    };
    Comparator&lt;Bus&gt; ct = new Comparator&lt;Bus&gt;() {
        @Override
        public int compare(Bus o1, Bus o2) {
            if (o1.y &gt; o2.y) {
                return 1;
            } else if (o1.y &lt; o2.y) {
                return -1;
            }
            return 0;
        }
    };

    Collections.sort(buses, cf);

    int left, right, key;
    for (int i = 0; i &lt; p; i++) {
        key = cities.get(i);
        left = bs_f(buses, key);//从left开始都是大于key的数字
        List&lt;Bus&gt; flist = buses.subList(0, left);//left=0, size=0
        if (flist.size() &gt; 0) {
            Collections.sort(flist, ct);
            right = bs_t(flist, key);//从right开始都是大于等于key的数字
            List&lt;Bus&gt; tlist = flist.subList(right, flist.size());
            System.out.print(tlist.size() + " ");
        } else {
            System.out.print("0 ");
        }
    }
}

private static int bs_f(List&lt;Bus&gt; lbus, int r) {
    int len = lbus.size();
    int left = 0, right = len - 1, mid = 0;
    while (left &lt;= right) {
        mid = (left + right) / 2;
        if (r &lt; lbus.get(mid).x) {
            right = mid - 1;
        } else if (r &gt;= lbus.get(mid).x) {
            left = mid + 1;
        }
    }
    return left;
}

private static int bs_t(List&lt;Bus&gt; lbus, int r) {
    int len = lbus.size();
    int left = 0, right = len - 1, mid = 0;
    while (left &lt;= right) {
        mid = (left + right) / 2;
        if (r &lt;= lbus.get(mid).y) {
            right = mid - 1;
        } else if (r &gt; lbus.get(mid).y) {
            left = mid + 1;
        }
    }
    return left;
}
</code></pre>

<p>}</p>

<p>class Bus {</p>

<pre><code>int x;
int y;

Bus(int x, int y) {
    this.x = x;
    this.y = y;
} }
</code></pre>

<p>```</p>

<h3 id="problem-c-sort-a-scrambled-itineraryhttpscodegooglecomcodejamcontest6214486dashboardsp2"><a href="https://code.google.com/codejam/contest/6214486/dashboard#s=p2">Problem C. Sort a scrambled itinerary</a></h3>

<p>问题C是说给你一些航班的信息，包括起点城市和终点城市，但是顺序乱了，让你来确定这些航班整合起来最后是从哪里到哪里之后又到了哪里。</p>

<p>思路：这题很简单，起点是入度为0的点，终点是出度为0的点，一个while循环就能搞定，就这样简单的思路这道题目就可以过。</p>

<p>```
import java.io.BufferedOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.util.*;</p>

<p>//https://code.google.com/codejam/contest/6214486/dashboard#s=p2</p>

<p>public class ProblemC {</p>

<pre><code>private static Map&lt;String, String&gt; flights;
private static Map&lt;String, City&gt; citymap;

public static void main(String[] args) throws Exception {
    PrintStream out = new PrintStream(new BufferedOutputStream(new FileOutputStream("data/out.txt")));
    System.setOut(out);
    System.setErr(out);
    Scanner scanner = new Scanner(new FileInputStream("data/in.txt"));

    int t = scanner.nextInt();
    int c = 1;
    while (t-- &gt; 0) {
        System.out.print("Case #" + c + ": ");
        flights = new HashMap&lt;String, String&gt;();
        citymap = new HashMap&lt;String, City&gt;();
        int p = scanner.nextInt();
        String from, to;
        City cf, ct;
        for (int i = 0; i &lt; p; i++) {
            from = scanner.next();
            to = scanner.next();

            if (citymap.containsKey(from)) {
                cf = citymap.get(from);
            } else {
                cf = new City();
                citymap.put(from, cf);
            }
            cf.name = from;
            cf.out = 1;

            if (citymap.containsKey(to)) {
                ct = citymap.get(to);
            } else {
                ct = new City();
                citymap.put(to, ct);
            }
            ct.name = to;
            ct.in = 1;

            flights.put(from, to);
        }
        solve();
        c++;
        System.out.println();
    }

    out.flush();
    out.close();
}

private static void solve() {
    String from = null;
    Set&lt;Map.Entry&lt;String, City&gt;&gt; entries = citymap.entrySet();
    for (Map.Entry&lt;String, City&gt; entry : entries) {
        //System.out.println("name=" + entry.getValue().name + " in=" + entry.getValue().in + " out=" + entry.getValue().out);
        if (entry.getValue().in == 0) {
            from = entry.getKey();
            break;
        }
    }

    String next;
    String current = from;
    while (current != null &amp;&amp; flights.containsKey(current)) {
        next = flights.get(current);
        System.out.print(citymap.get(current).name + "-" + citymap.get(next).name + " ");
        current = next;
    }
}
</code></pre>

<p>}</p>

<p>class City {</p>

<pre><code>String name;
int in = 0;
int out = 0;
</code></pre>

<p>}</p>

<p>```</p>

<p><a href="https://code.google.com/codejam/contest/6214486/dashboard#s=p3">Problem D. Itz Chess</a></p>

<p>问题D是说在国际象棋的棋盘上放了一些棋子，在当前位置下有些棋子可以杀死其他的棋子，问共有多少个可以杀死的情况。</p>

<p>思路：我没啥特别的思路，就是根据每类棋子的不同攻击方式编写相应的检验函数看它是否能够将某个棋子杀死。</p>

<p>小数据集的测试样例貌似都是关于K和P的，我都通过了，但是大数据测试集没有通过，估计是哪类棋子的攻击检验函数有问题，暂时不知道问题在哪，若有发现的请告知，谢谢。</p>

<p>```
import java.io.BufferedOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;</p>

<p>//https://code.google.com/codejam/contest/6214486/dashboard#s=p3</p>

<p>public class ProblemD {</p>

<pre><code>private static int[][] board;
private static List&lt;Chess&gt; chesses;

public static void main(String[] args) throws Exception {
    PrintStream out = new PrintStream(new BufferedOutputStream(new FileOutputStream("data/out.txt")));
    System.setOut(out);
    System.setErr(out);
    Scanner scanner = new Scanner(new FileInputStream("data/D-large-practice.in.txt"));

    int t = scanner.nextInt();
    for (int w = 1; w &lt;= t; w++) {
        System.out.print("Case #" + w + ": ");
        board = new int[9][9];
        chesses = new ArrayList&lt;Chess&gt;();
        for (int i = 0; i &lt; 9; i++) {
            for (int j = 0; j &lt; 9; j++) {
                board[i][j] = 0;//默认是空的字符
            }
        }
        int n = scanner.nextInt();
        String line;
        int x, y;
        char c;
        for (int i = 0; i &lt; n; i++) {
            line = scanner.next();
            x = line.charAt(1) - '1' + 1;//行
            y = 8 - (line.charAt(0) - 'A');//列
            c = line.charAt(3);
            board[x][y] = 1;
            chesses.add(new Chess(x, y, c));
        }

        //for (int i = 0; i &lt; 9; i++) {
        //    for (int j = 0; j &lt; 9; j++) {
        //        System.out.print(board[i][j] + " ");
        //    }
        //    System.out.println();
        //}

        solve();

        System.out.println();
    }

    out.flush();
    out.close();
}

private static void solve() {
    int sum = 0;
    for (int i = 0, l = chesses.size(); i &lt; l; i++) {
        for (int j = 0; j &lt; l; j++) {
            if (kill(chesses.get(i), chesses.get(j))) {
                sum++;
                //System.out.println(" ko");
            } //else System.out.println();
        }
    }
    System.out.print(sum);
}

//判断棋子c1是否能够杀死c2
private static boolean kill(Chess c1, Chess c2) {
    if (c1.x == c2.x &amp;&amp; c1.y == c2.y) return false;
    //System.out.print(c1.c + " (" + c1.x + "," + c1.y + ") " + c2.c + " (" + c2.x + "," + c2.y + ")");
    switch (c1.c) {
        case 'K':
            return k_kill(c1, c2);
        case 'Q':
            return q_kill(c1, c2);
        case 'R':
            return r_kill(c1, c2);
        case 'B':
            return b_kill(c1, c2);
        case 'N':
            return n_kill(c1, c2);
        case 'P':
            return p_kill(c1, c2);
    }
    return false;
}

//王
private static boolean k_kill(Chess c1, Chess c2) {
    if (((Math.abs(c1.x - c2.x) == 1) || (Math.abs(c1.x - c2.x) == 0))
            &amp;&amp; ((Math.abs(c1.y - c2.y) == 1) || (Math.abs(c1.y - c2.y) == 0))) return true;
    return false;
}

//后
private static boolean q_kill(Chess c1, Chess c2) {
    if (r_kill(c1, c2) || b_kill(c1, c2)) return true;
    return false;
}

//车
private static boolean r_kill(Chess c1, Chess c2) {
    if (c2.x != c1.x &amp;&amp; c2.y != c1.y) return false;
    if (c2.x == c1.x) {//同一行
        int from = Math.min(c2.y, c1.y);
        int to = Math.max(c2.y, c1.y);
        for (int k = from + 1; k &lt; to - 1; k++) {
            if (board[c1.x][k] != 0) {
                return false;
            }
        }
        return true;
    }
    if (c2.y == c1.y) {//同一列
        int from = Math.min(c2.x, c1.x);
        int to = Math.max(c2.x, c1.x);
        for (int k = from + 1; k &lt; to - 1; k++) {
            if (board[k][c1.y] != 0) {
                return false;
            }
        }
        return true;
    }
    return false;
}

//象
private static boolean b_kill(Chess c1, Chess c2) {
    if (Math.abs(c1.x - c2.x) != Math.abs(c1.y - c2.y)) return false;
    int xdir = c1.x &gt; c2.x ? -1 : 1;//direction!!!
    int ydir = c1.y &gt; c2.y ? -1 : 1;
    for (int i = c1.x + xdir, j = c1.y + ydir; i != c2.x &amp;&amp; j != c2.y; i = i + xdir, j = j + ydir) {
        if (board[i][j] != 0) {
            return false;
        }
    }
    return true;
}

//马
private static boolean n_kill(Chess c1, Chess c2) {
    if (Math.abs(c1.x - c2.x) == 1 &amp;&amp; Math.abs(c1.y - c2.y) == 2) {
        return true;
    }
    if (Math.abs(c1.y - c2.y) == 1 &amp;&amp; Math.abs(c1.x - c2.x) == 2) {
        return true;
    }
    return false;
}

//兵
private static boolean p_kill(Chess c1, Chess c2) {
    if (Math.abs(c1.x - c2.x) == 1 &amp;&amp; c1.y - c2.y == 1) return true;
    return false;
} }
</code></pre>

<p>class Chess {</p>

<pre><code>int x;
int y;
char c;

Chess(int x, int y, char c) {
    this.x = x;
    this.y = y;
    this.c = c;
} } ```
</code></pre>

]]></content>
  </entry>
  
</feed>
